<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: d3.js | Azundo Design]]></title>
  <link href="http://azundo.github.io/blog/categories/d3-dot-js/atom.xml" rel="self"/>
  <link href="http://azundo.github.io/"/>
  <updated>2013-08-20T15:43:26-07:00</updated>
  <id>http://azundo.github.io/</id>
  <author>
    <name><![CDATA[Ben Best]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Optimal Fox AI Using State Machines]]></title>
    <link href="http://azundo.github.io/blog/an-optimal-fox-using-state-machines/"/>
    <updated>2013-07-05T16:34:00-07:00</updated>
    <id>http://azundo.github.io/blog/an-optimal-fox-using-state-machines</id>
    <content type="html"><![CDATA[<style>
    .fox-hole.selected {
        fill: white;
        stroke: black;
    }
    #fox {
        width: 600px;
        overflow: auto;
        min-height: 300px;
    }
</style>

<p>I’ve really enjoyed thinking about the puzzles at
<a href="http://gurmeet.net/puzzles/">http://gurmeet.net/puzzles/</a>, especially
looking for ways to solve them or get hints as to how to solve them using
visualization without knowing the answers.
<a href="http://azundo.github.io/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle/">Last Time</a>
I explored puzzle 11, Treasure Island, and this time I’ll look at puzzle 5, Fox
in a Hole.</p>

<h2 id="the-puzzle">The Puzzle</h2>
<p>Here is the wording from <a href="http://gurmeet.net/puzzles/">http://gurmeet.net/puzzles/</a>:</p>

<pre><code>Consider five holes in a line. One of them is occupied by a fox. Each night,
the fox moves to a neighboring hole, either to the left or to the right. Each
morning, you get to inspect a hole of your choice. What strategy would ensure
that the fox is eventually caught?
</code></pre>

<h2 id="the-challenge">The Challenge</h2>
<p>The question I asked was, can we, without knowledge of a working strategy,
create a fox that plays optimally against us so we can be sure we’ve come up
with a strategy that will work? We could simulate a fox that chooses to move
left or right randomly, but we would never be sure that our strategy is fool
proof. Can we make sure our fox plays hard to get if we don’t even know how
to catch it? Turns out we can. Try out the demo of my solution and see if you
can both figure out how to catch the fox and understand why a strategy works.
Implementation details are below the demo. Code is at 
<a href="https://gist.github.com/azundo/5941503">https://gist.github.com/azundo/5941503</a>.</p>

<h3 id="instructions">Instructions</h3>

<pre><code>Click on a hole to select it for inspection. You win if the fox has nowhere
left to hide. If you give up, click the button and one possible path the fox
could have taken to avoid your inspections will be shown.
</code></pre>

<div id="fox"></div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script type="text/javascript">
(function(){
  var
    foxHoleR = 45,
    xOffset = foxHoleR*2 + 15,
    yOffset = foxHoleR/4 + 40,
    container = d3.select('#fox'),
    svg,
    currentDay,
    button,
    selector,

  /*
   * State machine functions
   *
   * In this example, a state is the set of possible holes that the fox could
   * be in on a given day after accounting for the farmer's strategy up to that
   * point.
   *
   * For example on the first day, after the farmer inspects a hole, it is
   * possible that the fox is in any of the other holes, so the state for the
   * first day would have four entries.
   *
   * We could represent our state space as a 5-bit bit vector, where a bit is
   * on if the fox could be in that hole, and off if the fox couldn't be in
   * that hole. I think this representation (an array of possible values) is a
   * bit easier to follow and less accessible bit manipulation.
   */

  ADJACENCY_LIST = [
    // hole 0 is next to hole 1
    [1],
    // hole 1 is next to hole 0 and hole 2
    [0, 2],
    // etc.
    [1, 3],
    [2, 4],
    [3]
    ],
  state,
  stateHistory;


  function nextState(pastState, guess) {
    /*
     * Calculates our next state based on the past state and the next hole to be inspected.
     */
    var next = [], i, j, possiblePastHole, possibleNextHoles, possibleNextHole;
    for (i = 0; i < pastState.length; i++) {
      // any value in our pastState represents a hole that the fox was possibly in yesterday
      possiblePastHole = pastState[i];

      // look up holes next to the possiblePastHole in our ADJACENCY_LIST
      possibleNextHoles = ADJACENCY_LIST[possiblePastHole];
      for (j = 0; j < possibleNextHoles.length; j++) {
        // any holes that are ajacent to a possible hole from the pastState
        // are valid holes for the fox in the next state, provided that hole wasn't inspected.
        // Note that the fox cannot stay in the same hole, it has to move to an adjacent hole.
        possibleNextHole = possibleNextHoles[j]
        // don't add holes that are already in the next state array since our
        // state is the set of possible holes
        if (possibleNextHole !== guess && next.indexOf(possibleNextHole) === -1) {
          next.push(possibleNextHole);
        }
      }
    }
    return next;
  }

  function getPossibleSequence() {
    // only depends on our stateHistory
    var i, finalState, stateToDetermine, possibleHoles, possibleHole, seq = [];
    if (stateHistory.length === 0) {
      return seq;
    }
    finalState = stateHistory.pop();
    // pick whatever hole happens to be listed first in the final state to end our sequence.
    seq.unshift(finalState[0]);
    // work backwards through the state history, picking a valid state from each 
    // entry and unshifting it onto the front of the sequence
    while (stateHistory.length > 0) {
      stateToDetermine = stateHistory.pop();
      // find a hole beside the hole at the front of our sequence
      // since our 'graph' is not directed, we can safely use
      // the same adjacency values to move backwards through
      // the state list
      possibleHoles = ADJACENCY_LIST[seq[0]];
      for (i = 0; i < possibleHoles.length; i++) {
        possibleHole = possibleHoles[i];
        // if the possible hole is in our stateToDetermine, use it.
        if (stateToDetermine.indexOf(possibleHole) !== -1){
          seq.unshift(possibleHole);
          break;
        }
      }
    }
    return seq;
  }

  /*
   * End of State Machine Functions
   */

  function selectHole(selection) {
      // update state information
      state = nextState(state, selection);
      stateHistory.push(state.slice());
      // if there are no possible holes for the fox to be in, we caught him!
      if (state.length === 0) {
        foxCaught(selection);
      } else {
        advanceOneDay(selection);
      }
  }

  function foxCaught(selection) {
    alert("You got him!");
    // remove the selector
    selector.remove();

    // our last state was where we caught the fox, so remove the empty state
    // and push on a state containing the selection that caught the fox.
    stateHistory.pop();
    stateHistory.push([selection]);

    // draw the current selection
    drawHoles(currentDay, currentDay, selection);

    // draw all foxes in
    drawFoxes();

    // reset the button
    button
      .text('Try Again')
      .on('click', init);
  }

  function advanceOneDay(selection) {

    // increase size of container div and/or svg canvas
    updateCanvasSizes();

    // move the selector down
    moveSelector();

    // draw in row with our selection
    drawHoles(currentDay, currentDay, selection);

    // fill in 'missed' label
    labelMissed(currentDay, selection);

    // increase our day counter
    currentDay += 1;

  }

  init();

  function init() {
    state = [0, 1, 2, 3, 4];
    stateHistory = [];
    container.html('');
    svg = container.append('svg')
      .attr('width', 600)
      .attr('height', 2*yOffset);
    currentDay = 0;
    button = container.append('button')
      .text('I give up. Show me the fox!')
      .on('click', giveUp);
    selector = drawHoles('selector', 0);
    selector.selectAll('.fox-hole')
      .on('mouseover', function() {
        d3.select(this).classed('selected', true);
      })
      .on('mouseout', function() {
        d3.select(this).classed('selected', false);
      })
      .on('click', function() {
        // pull the hole number from the id. XXX pretty hacky
        var selection = parseInt(d3.select(this).attr('id').split('-').pop());
        selectHole(selection);
      });
  };


  function giveUp() {
    selector.remove();
    // case where the user didn't make any guesses, put the fox in the first hole
    if (stateHistory.length === 0) {
      drawHoles(currentDay, currentDay);
      drawFox(currentDay, 0);
    }
    else {
      drawFoxes();
    }
    button
      .text('Try Again')
      .on('click', init);
  }

  /*
   * D3 Drawing functions
   */

  function drawHoles(idSuffix, row, selected) {
    var i, hole, holes = svg.append('g')
    .attr('id', 'fox-holes-' + idSuffix)
      .attr('transform', 'translate(0,' + ((row+1) * yOffset) + ')');
    holes.append('text')
      .text('Day ' + (row + 1))
      .attr('y', yOffset / 4);
    for (i = 0; i < 5; i++) {
      hole = holes.append('ellipse')
        .attr('id', 'fox-hole-' + idSuffix + '-' + i)
        .attr('rx', foxHoleR)
        .attr('ry', foxHoleR / 4)
        .attr('cx', i * xOffset + xOffset)
        .attr('cy', foxHoleR / 4 )
        .classed('fox-hole', true);
      if (i === selected) {
        hole.classed('selected', true)
      }
    }
    return holes;
  }

  function drawFoxes() {
    var seq = getPossibleSequence(), i;
    for (i=0; i < seq.length; i++) {
      drawFox(i, seq[i]);
    }
  }

  function drawFox(row, hole) {
    d3.select("#fox-holes-" + row)
      .append('image')
      .attr('xlink:href', '../../images/fox_white.svg')
      .attr('width', foxHoleR)
      .attr('height', foxHoleR)
      .attr('x', (hole+1) * xOffset - foxHoleR / 2 )
      .attr('y', -1 * foxHoleR / 2 );
  }

  function updateCanvasSizes() {
    // increase size of svg canvas if need be
    if (svg.attr('height') < (currentDay + 3) * yOffset) {
      svg.attr('height', (currentDay + 3) * yOffset);
    }
    // add to container's height if it's too small
    // to facilitate scrolling
    var containerHeight = parseInt(container.style('min-height'));
    if (containerHeight < (currentDay + 3) * yOffset) {
      container.style('min-height', (containerHeight + yOffset*5) + 'px');
    }
  }

  function moveSelector() {
    selector
      .transition()
        .attr('transform', 'translate(0,' + (currentDay+2) * yOffset + ')');
    selector.select('text')
      .text('Day ' + (currentDay+2));
    // mouseout doesn't fire when using transform to move the selector until the mouse
    // is moved again, so manually de-select the hole
    selector.select('.fox-hole.selected')
      .classed('selected', false);
  }

  function labelMissed(row, selection) {
    d3.select("#fox-holes-" + row)
      .append('text')
      .text('Missed!')
      .attr('x', (selection+1) * xOffset - foxHoleR / 2 )
      .attr('y', foxHoleR / 3);
  }

})();
</script>

<h2 id="a-quantum-fox">A Quantum Fox</h2>
<p>Instead of modeling our fox as being in one concrete location, we’ll keep track
of all possible holes the fox could be in at any given time without getting
caught, depending on which holes we have inspected in the past. We’ll use a
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine</a> to
keep track of which holes the fox could be in. If we ever get to the state
where the fox couldn’t be in any holes without being caught, we know our
strategy is a good one. We don’t require any knowledge of the best path for
the fox to choose, or a winning strategy.</p>

<h3 id="our-state-space">Our State Space</h3>
<p>Each state in our state space will consist of all of the possible holes the fox
could be in at any one time. There are 5 holes and each hole has two states: it
is either possible for the fox to be in that hole, or not possible. This gives
us a state space of size <code>2^5 = 32</code>. We could model this as a bit vector with 5
bits, but for clarity I will use a simple array. If it is possible for the fox
to be in hole <code>i</code>, then our state array will contain <code>i</code>. We’ll number our
holes <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>.</p>

<p>For example, before we check any holes, our state would be <code>[0, 1, 2, 3, 4]</code>.
The fox could be in any hole. If we check hole <code>2</code>, then our state would move
to <code>[0, 1, 3, 4]</code>. In the case where there is no possible hole for our fox to
be in without catching him at some point, our state is an empty array <code>[]</code>.</p>

<h3 id="state-transitions">State Transitions</h3>
<p>The key implementation detail when using a state machine is our state
transitions. How do we decide which state we move to next? In our case our next
state is dependent on two things, our previous state (the set of possible holes
the fox could have been in yesterday) and our selection of which hole to check.</p>

<p>To start let’s forget about the action of checking a hole. How can we determine
what holes the fox can be in based on what holes it could have been in
yesterday? If it was possible for the fox to be in hole <code>i</code> yesterday, then it
is possible for the fox to be in any hole beside <code>i</code> today. If we iterate over
all of the holes that the fox could have been in yesterday then we’ll get the
set of holes it could be in today.</p>

<p>We’ll use a very simple adjacency list to make our lives easy. If we access
element <code>i</code> of the adjacency list we will get back an array containing all of
the holes next to <code>i</code>.</p>

<p><code>javascript
var ADJACENCY_LIST = [
    // hole 0 is next to hole 1
    [1],
    // hole 1 is next to hole 0 and hole 2
    [0, 2],
    // etc.
    [1, 3],
    [2, 4],
    [3]
];
</code></p>

<p>This <a href="http://en.wikipedia.org/wiki/Adjacency_list">adjacency list</a> defines a
very simple <a href="https://en.wikipedia.org/wiki/Graph_(mathematics)">graph</a> where
each hole is a node connected by edges to each of its adjacent holes. The first
and last holes only have one adjacent hole (and thus one edge) while the others
have two.</p>

<p>Accessing element <code>0</code> of our <code>ADJACENCY_LIST</code> tells us which holes are next
to hole <code>0</code>. If we want to know the set of possible future holes, we take the
set of possible past holes and add all of the adjacent holes. Simple enough.</p>

<p>Lastly we don’t include the hole that we chose to inspect since the fox would
get caught if he ended up there. Hence, our transition function looks like this:</p>

<p>```javascript
  function nextState(pastState, guess) {
    /*
     * Calculates our next state based on the past state and
     * the next hole to be inspected.
     */
    var next = [], i, j, possiblePastHole, possibleNextHoles, possibleNextHole;
    for (i = 0; i &lt; pastState.length; i++) {
      // any value in our pastState represents a hole that
      // the fox was possibly in yesterday
      possiblePastHole = pastState[i];</p>

<pre><code>  // look up holes next to the possiblePastHole in our ADJACENCY_LIST
  possibleNextHoles = ADJACENCY_LIST[possiblePastHole];
  for (j = 0; j &lt; possibleNextHoles.length; j++) {
    // any holes that are ajacent to a possible hole
    // from the pastState are valid holes for the fox in
    // the next state, provided that hole wasn't
    // inspected.  Note that the fox cannot stay in the
    // same hole, it has to move to an adjacent hole.
    possibleNextHole = possibleNextHoles[j]
    // don't add holes that are already in the next
    // state array since our state is the set of
    // possible holes
    if (possibleNextHole !== guess &amp;&amp; next.indexOf(possibleNextHole) === -1) {
      next.push(possibleNextHole);
    }
  }
}
return next;   } ```
</code></pre>

<p>If we ever end up with an empty state, the fox has nowhere to go. We must have
caught it at some point, no matter where it started and how it decided to move.</p>

<p>Every time we select a hole to inspect, we’ll update our state and push a copy
of it onto an array to keep track of what states we’ve been through in the
past. We’ll use that later.</p>

<p><code>javascript
  function selectHole(selection) {
      // update state information
      state = nextState(state, selection);
      stateHistory.push(state.slice());
      // if there are no possible holes for the fox to be in, we caught him!
      if (state.length === 0) {
        foxCaught(selection);
      } else {
        advanceOneDay(selection);
      }
  }
</code></p>

<h3 id="reconstructing-the-foxs-moves">Reconstructing the Fox’s Moves</h3>

<p>If we save each state we reach, we can reconstruct a possible path the fox
could have taken to get to the current state. Let’s choose any arbitrary hole
from the current state, and work backwards by looking for adjacent holes in the
previous state. We are guaranteed to find a backwards path since every hole in
our current state must be possible. Here is the code:</p>

<p>```javascript</p>

<p>function getPossibleSequence() {
    // only depends on stateHistory, an array of our past states
    var i, finalState, stateToDetermine, possibleHoles, possibleHole, seq = [];
    if (stateHistory.length === 0) {
      return seq;
    }
    finalState = stateHistory.pop();
    // pick whatever hole happens to be listed first in the
    // final state to end our sequence.
    seq.unshift(finalState[0]);
    // work backwards through the state history, picking a
    // valid state from each entry and unshifting it onto
    // the front of the sequence
    while (stateHistory.length &gt; 0) {
      stateToDetermine = stateHistory.pop();
      // find a hole beside the hole at the front of our
      // sequence since our ‘graph’ is not directed, we can
      // safely use the same adjacency values to move
      // backwards through the state list
      possibleHoles = ADJACENCY_LIST[seq[0]];
      for (i = 0; i &lt; possibleHoles.length; i++) {
        possibleHole = possibleHoles[i];
        // if the possible hole is in our stateToDetermine, use it.
        if (stateToDetermine.indexOf(possibleHole) !== -1){
          seq.unshift(possibleHole);
          break;
        }
      }
    }
    return seq;
  }
```</p>

<h2 id="demo-and-further-steps">Demo and Further Steps</h2>

<p>Throwing this together with some d3.js drawing and we get the demo from above.
The full code is in a gist at
<a href="https://gist.github.com/azundo/5941503">https://gist.github.com/azundo/5941503</a>
and viewable on <a href="http://bl.ocks.org">bl.ocks.org</a> at
<a href="http://bl.ocks.org/azundo/5941503">http://bl.ocks.org/azundo/5941503</a>.</p>

<p>You could also make solving the puzzle a bit easier if you showed all possible
holes the fox could be in as you go along, instead of only showing one possible
path at the end. Feel free to fork and implement this as a good exercise in d3
basics.</p>

<p>Now can you catch the fox?</p>

<h2 id="attributions">Attributions</h2>
<ul>
  <li><a href="http://thenounproject.com/noun/fox/#icon-No4144" target="_blank">Fox</a> designed by <a href="http://thenounproject.com/ceqq" target="_blank">Sebastian Blei</a> from The Noun Project</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using D3.js to Brute Force the Pirate Puzzle]]></title>
    <link href="http://azundo.github.io/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle/"/>
    <updated>2013-07-04T23:10:00-07:00</updated>
    <id>http://azundo.github.io/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle</id>
    <content type="html"><![CDATA[<style>
  .island {
    stroke: blue;
    stroke-width: 3;
    fill: transparent;
  }
  .tree {
    stroke: green;
    fill: green;
  }
  .grave {
    stroke: black;
    fill: black;
  }
  .flag {
    stroke: red;
    fill: red;
  }
  .treasure {
    stroke: yellow;
    fill: yellow;
  }
  .flag-path {
    stroke: black;
    fill: none;
  }
  .rise {
      stroke: red;
  }
  .run {
      stroke: blue;
  }
  .thick {
      stroke-width: 5px;
  }
</style>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<p>SPOILER ALERT. This post contains an answer to puzzle 11 Treasure Island from
<a href="http://gurmeet.net/puzzles">http://gurmeet.net/puzzles</a> which appeared on Hacker News recently. If you
want to solve it yourself first, check it out over there before reading on, or
just don’t read too far down the page.</p>

<h2 id="the-puzzle">The Puzzle</h2>
<p>Here is the wording of the puzzle:</p>

<pre><code>An old parchment has directions to a treasure chest buried in an island:

There is an unmarked grave and two tall oak trees. Walk from the grave to the
left tree, counting the number of steps. Upon reaching the left tree, turn left
by 90 degrees and walk the same number of steps. Mark the point with a flag.
Return to the grave. Now, walk towards the right tree, counting the number of
steps. Upon reaching the right tree, turn right by 90 degrees and walk the same
number of steps. Mark this point with another flag. The treasure lies at the
midpoint of the two flags.

A party of sailors reached the island. They find a pair of tall oak trees
merrily swaying in the wind. However, the unmarked grave is nowhere to be
found. They are planning to dig up the entire island. It'll take a month. Can
they do any better?
</code></pre>

<p>My high school geometry is a little fuzzy so I thought I’d do a little
empirical playing around with d3.js to get a sense of the answer before trying
to work out the math. Almost a sort of graphical brute force method. If you’re new
to d3.js this should hopefully act as a good introduction as well.</p>

<p>If you want to skip ahead, the full gist is at
<a href="https://gist.github.com/azundo/5928203">https://gist.github.com/azundo/5928203</a>
and you can use Mike Bostock’s <a href="http://bl.ocks.org">bl.ocks.org</a> to view it at
<a href="http://bl.ocks.org/azundo/5928203">http://bl.ocks.org/azundo/5928203</a>.</p>

<h2 id="brute-forcing">Brute Forcing</h2>

<h3 id="set-up">Set up</h3>

<p>We’ll start with a little bit of d3 boilerplate to set things up. There are a
few <code>g</code> elements to get our layers working properly but hopefully the comments
in the code make things clear.</p>

<p><code>javascript
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('body').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
</code></p>

<p>Next lets set up some parameters for our treasure island.</p>

<p><code>javascript
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius};
</code></p>

<h3 id="plotting-the-static-features">Plotting the Static Features</h3>

<p>Now we’re ready to plot the static component of our map - the island and the trees.</p>

<p>```javascript
// create the island on top of everything. If we draw our features “over top”
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We’ll give it a transparent fill so we can see
// through it.
svg.append(‘circle’)
  .attr(‘r’, islandRadius)
  .attr(‘cx’, islandRadius)
  .attr(‘cy’, islandRadius)
  .classed(‘island’, true);</p>

<p>// create the trees - these are static so only draw them once
features.selectAll(‘.tree’)
  .data(trees)
  .enter().append(‘image’)
    .attr(‘xlink:href’, ‘images/tree.svg’)
    .attr(‘width’, featureLength)
    .attr(‘height’, featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr(‘x’, getX)
    .attr(‘y’, getY)
    .classed(‘tree’, true);
```</p>

<p>If we fire this code up you’ll see the following:</p>

<div id="static"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#static').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius};

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Looking good. A couple of trees. Time to get plotting our flags and ultimately the
treasure chest location.</p>

<h3 id="adding-flags">Adding Flags</h3>

<p>The tricky part here is getting the geometry right when calculating the
location of the flags for a given location of the grave. By filling in a couple
of extra triangles it becomes clear how we can do it. Here’s a quick diagram
for the left tree:</p>

<div id="tri"></div>

<script type="text/javascript">
var svg = d3.select('#tri').append('svg')
    .attr('width', 400)
    .attr('height', 280),
    line = d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; }),
    tree = {
        x: 120,
        y: 20
    },
    grave = {
        x: 370,
        y: 120
    },
    flag = {
        x: tree.x - (grave.y - tree.y),
        y: tree.y + (grave.x - tree.x)
    },
    featureLength = 40;
// plot the tree
svg.append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', tree.x - featureLength / 2)
    .attr('y', tree.y - featureLength / 2)
    .classed('tree', true);
// plot the grave
svg.append('image')
    .attr('xlink:href', '../../images/grave.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', grave.x - featureLength / 2)
    .attr('y', grave.y - featureLength / 2)
    .classed('grave', true);
// plot the flag
svg.append('image')
    .attr('xlink:href', '../../images/flag.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', flag.x - featureLength / 2)
    .attr('y', flag.y - featureLength / 2)
    .classed('flag', true);
// draw the runs
svg.append('path')
    .attr('d', line([tree, {x: grave.x, y: tree.y}]))
    .classed('run thick', true);
svg.append('path')
    .attr('d', line([flag, {x: flag.x, y: tree.y}]))
    .classed('run thick', true);
// draw the rises
svg.append('path')
    .attr('d', line([grave, {x: grave.x, y: tree.y}]))
    .classed('rise thick', true);
svg.append('path')
    .attr('d', line([tree, {x: flag.x, y: tree.y}]))
    .classed('rise thick', true);
svg.append('path')
    .attr('d', line([grave, tree, flag]))
    .classed('flag-path thick', true);
</script>

<p>Remembering that the y-coordinate values increase downwards on our svg canvas, we can see a
couple of equivalent triangles marked by the red, blue and black lines. The
black lines are the path our pirate would mark out,
the red <script type="math/tex">rise = g_y - T_{Ly}</script> is the y-difference between the grave and the tree,
and and the blue <script type="math/tex">run = g_x - T_{Lx}</script> is the x-difference between the grave and the tree.
The coordinates of the left
flag are then given by:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Lx} & = T_{Lx} - rise \\
       & = T_{Lx} - (g_y - T_{Ly}) \\
\\
F_{Ly} & = T_{Ly} + run \\
       & = T_{Ly} + (g_x - T_{Lx})
\end{aligned}
 %]]&gt;</script>

<p>If we swap the grave and the flag in the above diagram, we can work out the
case for the right tree, turning to the right instead of the left:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Rx} & = T_{Rx} + rise \\
       & = T_{Rx} + (g_y - T_{Ry}) \\
\\
F_{Ry} & = T_{Ry} - run \\
       & = T_{Ry} - (g_x - T_{Rx})
\end{aligned}
 %]]&gt;</script>

<p>So we end up with the following function for calculating our flag placements:</p>

<p>```javascript
// calculate the positions of the flags
function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;</p>

<p>leftTree = treePositions[0];
  rightTree = treePositions[1];</p>

<p>// get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}
```</p>

<p>We’ll need to dynamically update the positions of these flags so lets create a
draw function and call it. At the same time we’ll draw our grave in as well as
the triangles that show the walking directions for illustrative purposes. Check
out the <a href="https://gist.github.com/azundo/5928203">final version of the code</a> to
see the full <code>getPathPoints</code> function.</p>

<p>```javascript
function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);</p>

<p>// draw the grave
  features.selectAll(‘.grave’)
    .data([grave])
      .attr(‘x’, getX)
      .attr(‘y’, getY)
    .enter().append(‘image’)
      .attr(‘xlink:href’, ‘img/grave.svg’)
      .classed(‘grave’, true)
      .attr(‘height’, featureLength)
      .attr(‘width’, featureLength)
      .attr(‘x’, getX)
      .attr(‘y’, getY);</p>

<p>// draw the flags
  features.selectAll(‘.flag’)
    .data(flags)
      .attr(‘x’, getX)
      .attr(‘y’, getY)
    .enter().append(‘image’)
      .attr(‘xlink:href’, ‘img/flag.svg’)
      .classed(‘flag’, true)
      .attr(‘height’, featureLength)
      .attr(‘width’, featureLength)
      .attr(‘x’, getX)
      .attr(‘y’, getY);</p>

<p>// draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll(‘.flag-path’)
    .data(paths)
      .attr(‘d’, line)
    .enter().append(‘path’)
      .classed(‘flag-path’, true)
      .attr(‘d’, line);
}
draw();
```</p>

<div id="flags"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#flags').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>We’re getting somewhere. Now lets connect our mouse position to the
grave position and watch our flags dance around.</p>

<h3 id="making-the-flags-move">Making the Flags Move</h3>

<p><code>javascript
// move grave location to wherever the mouse is
svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });
</code></p>

<div id="moving-flags"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#moving-flags').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });

// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-1')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-1)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Can you guess the answer to the riddle yet? Let’s add a calculation of the
flags’ midpoint and plot our treasure chest on the map.</p>

<h3 id="the-chest">The Chest</h3>

<p>```javascript
// modified draw function
function draw() {
  …
  var treasure = getTreasurePosition(flags);
  // draw the treasure location
  features.selectAll(‘.treasure’)
    .data([treasure])
      .attr(‘x’, getX)
      .attr(‘y’, getY)
    .enter().append(‘image’)
      .attr(‘xlink:href’, ‘img/treasure_chest.svg’)
      .classed(‘treasure’, true)
      .attr(‘height’, featureLength)
      .attr(‘width’, featureLength)
      .attr(‘x’, getX)
      .attr(‘y’, getY);
    …
}</p>

<p>function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}
```</p>

<div id="treasure"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#treasure').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });
// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-2')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-2)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave),
      treasure = getTreasurePosition(flags);

  // draw the treasure location
  features.selectAll('.treasure')
    .data([treasure])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/treasure_chest.svg')
      .classed('treasure', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Success! We’ve now got a clear answer - there’s only a single location where
the chest could be. If you play around with the grave position it becomes
obvious that the chest’s x-coordinate is the midpoint of the two trees’
x-coordinates and the y coordinate is simply that same midpoint distance added
to the y-coordinate of the trees. Here we’re assuming the trees are at the same
y-coordinate and remember that y increases in the downward direction on our
screen. (The y-coordinate assumption is ok because we could always redraw our
coordinate system so that the two trees are level in the y direction.)</p>

<h2 id="the-math">The Math</h2>

<p>Now that we’ve played around with getting the example to work and
seen that it is a single point solution (not a line or other area function) we
can take a more informed approach to the math.</p>

<h3 id="the-x-coordinate">The X-coordinate</h3>

<p>We’ll use the trick that our x and y coordinates are independent. Lets work in
the x-direction first. We know our final x-coordinate is the average of our two
flags’ x-coordinates. Lets start with the left tree’s flag. Here we use
<script type="math/tex">T_{Lx}</script> as the left tree’s x-coordinate, <script type="math/tex">F_{Lx}</script> as the left flag’s
x-coordinate, <script type="math/tex">g_{x}</script> as the grave’s x-coordinate and <script type="math/tex">X_{x}</script> (since X
marks the spot) as the chest’s x-coordinate. Going back to our earlier
formulas:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Lx} & = T_{Lx} - (g_{y} - T_{Ly}) \\
F_{Rx} & = T_{Rx} + (g_{y} - T_{Ry})
\end{aligned}
 %]]&gt;</script>

<p>Averaging these two we can see that our $g_{y}$ term cancels out.</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
X_{x} & = \frac{F_{Lx} + F_{Rx}}{2} \\
& = \frac{T_{Lx} - (g_{y} - T_{Ly}) + T_{Rx} + (g_{y} - T_{Ry})}{2} \\
& = \frac{T_{Lx} + T_{Ly} + T_{Rx} - T_{Ry}}{2}
\end{aligned}
 %]]&gt;</script>

<p>In our case where <script type="math/tex">T_{Ly} == T_{Ry}</script> we get <script type="math/tex">X_{x}</script> as the average of
<script type="math/tex">T_{Lx}</script> and <script type="math/tex">T_{Rx}</script>, not dependent on the graveyard location, as we saw
in our brute force method.</p>

<h3 id="the-y-coordinate">The Y-coordinate</h3>

<p>Now we can do the same for the y-coordinate.</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Ly} & = T_{Ly} + (g_{x} - T_{Lx}) \\
F_{Ry} & = T_{Ry} - (g_{x} - T_{Rx}) \\
\\
X_{y} & = \frac{F_{Ly} + F_{Ry}}{2} \\
      & = \frac{T_{Ly} + g_{x} - T_{Lx} + T_{Ry} - g_{x} + T_{Rx}}{2} \\
      & = \frac{T_{Ly} + T_{Ry} + T_{Rx} - T_{Lx}}{2}
\end{aligned}
 %]]&gt;</script>

<p>In the case where
<script type="math/tex">T_{Ly} == T_{Ry} == T_{y}</script> then 
<script type="math/tex">X_{y} = T_{y} + \frac{T_{Rx} - T_{Lx}}{2}</script>, the result we saw earlier in
the brute force method.</p>

<h2 id="one-more-thing">One More Thing</h2>

<p>We actually don’t have it quite right yet, there is an omission. In the cases
where the grave lies above the trees (from our vantage point looking down at
the map of the island) the left and right trees are actually reversed. Here’s
the final implementation accounting for this possibility. Check out the 
gist at
<a href="https://gist.github.com/azundo/5928203">https://gist.github.com/azundo/5928203</a>
for the full final version.</p>

<div id="full"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#full').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });
// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-3')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-3)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave),
      treasure = getTreasurePosition(flags);

  // draw the treasure location
  features.selectAll('.treasure')
    .data([treasure])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/treasure_chest.svg')
      .classed('treasure', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag,
      flagPositions, leftTreeIdx, rightTreeIdx;

  // XXX assume grave position is either above or below both, 
  // i.e. y positions are equal for both trees
  // this code determines which tree is "left" and which is "right" based
  // on the location of the grave
  if (
      (treePositions[0].x < treePositions[1].x && treePositions[0].y < grave.y) ||
      (treePositions[0].x > treePositions[1].x && treePositions[0].y > grave.y)
     ) {
    leftTreeIdx = 0;
    rightTreeIdx = 1;
  } else {
    leftTreeIdx = 1;
    rightTreeIdx = 0;
  }

  leftTree = treePositions[leftTreeIdx];
  rightTree = treePositions[rightTreeIdx];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  flagPositions = [];
  // use these indexes to keep the order of our flags consistent with the order
  // of our trees in the trees array
  flagPositions[leftTreeIdx] = leftFlag;
  flagPositions[rightTreeIdx] = rightFlag;
  return flagPositions;
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<h2 id="conclusion">Conclusion</h2>

<p>So that’s it. A quick prototype in D3 to brute force our solution so we’ve got
some intution on how to go about solving the geometry. Great practice in
getting simple things done using d3.js and jogging the old geometry proofs
portion of the brain.</p>

<h2 id="attributions">Attributions</h2>

<p>Thanks to the folks over at <a href="http://thenounproject.com">The Noun Project</a> for
their svg icon sets. Here are the attributions:</p>

<ul>
  <li><a href="http://thenounproject.com/noun/tree/#icon-No17078">Tree</a> James Keunning from The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/grave/#icon-No11453">Grave</a> Alex Fuller from The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/flag/#icon-No485">Flag</a> The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/chest/#icon-No7173">Chest</a> Victor N. Escorsin da silva from The Noun Project</li>
</ul>
]]></content>
  </entry>
  
</feed>
