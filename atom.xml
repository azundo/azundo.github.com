<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Azundo Design]]></title>
  <link href="http://azundo.github.io/atom.xml" rel="self"/>
  <link href="http://azundo.github.io/"/>
  <updated>2013-06-23T23:08:54-04:00</updated>
  <id>http://azundo.github.io/</id>
  <author>
    <name><![CDATA[Ben Best]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Concurrent quicksort in Go]]></title>
    <link href="http://azundo.github.io/blog/concurrent-quicksort-in-go/"/>
    <updated>2013-06-23T22:05:00-04:00</updated>
    <id>http://azundo.github.io/blog/concurrent-quicksort-in-go</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been playing around with Go to get some experience in a systems programming
language before applying for applying jobs. I&rsquo;ve never done concurrent/parallel
programming so I thought I&rsquo;d try to learn about some of Go&rsquo;s concurrency tools
by implementing quicksort concurrently.</p>

<p>I started by writing a simple in-place quicksort implementation. The majority of
the algorithm happens in a <code>partition</code> function which picks a random pivot and
then does in-place swapping to partition around the pivot. With this in place
the sequential algorithm falls into place easily.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class='line'>    <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>    <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since the divide and conquer nature of quicksort means the recursive calls to
Qsort don&rsquo;t touch the same memory, this should be a decent candidate for
concurrency.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">d</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class='line'>    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</span><span class='line'>    <span class="o">&lt;-</span><span class="nx">d</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// termination condition</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// where the work happens</span>
</span><span class='line'>    <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// communication channel</span>
</span><span class='line'>    <span class="nx">childChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class='line'>    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">childChan</span><span class="p">)</span>
</span><span class='line'>    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">childChan</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// block until both concurrent children finish</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">&lt;-</span><span class="nx">childChan</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// tell our caller we are done</span>
</span><span class='line'>    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This works but is incredibly slow. Goroutines are cheap but not free. For large
s this program spends most of its time in garbage collection as too many
goroutines are created.</p>

<p>We need to limit the number of goroutines.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">Cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">workers</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">MAXGOROUTINES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">MAXGOROUTINES</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">workers</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workers</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// report to caller that we&#39;re finished</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">done</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="p">}()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// since we may use the doneChannel synchronously</span>
</span><span class='line'>  <span class="c1">// we need to buffer it so the synchronous code will</span>
</span><span class='line'>  <span class="c1">// continue executing and not block waiting for a read</span>
</span><span class='line'>  <span class="nx">doneChannel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">select</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">workers</span><span class="p">:</span>
</span><span class='line'>      <span class="c1">// if we have spare workers, use a goroutine</span>
</span><span class='line'>      <span class="c1">// for parallelization</span>
</span><span class='line'>      <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">doneChannel</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class='line'>  <span class="k">default</span><span class="p">:</span>
</span><span class='line'>      <span class="c1">// if no spare workers, sort synchronously</span>
</span><span class='line'>      <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class='line'>      <span class="c1">// calling this here as opposed to using the defer</span>
</span><span class='line'>      <span class="nx">doneChannel</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// use the existing goroutine to sort above the pivot</span>
</span><span class='line'>  <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">// if we used a goroutine we&#39;ll need to wait for</span>
</span><span class='line'>  <span class="c1">// the async signal on this channel, if not there</span>
</span><span class='line'>  <span class="c1">// will already be a value in the channel and it shouldn&#39;t block</span>
</span><span class='line'>  <span class="o">&lt;-</span><span class="nx">doneChannel</span>
</span><span class='line'>  <span class="k">return</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Setting MAXGOROUTINES limits the number of goroutines that ever get created by
switching to a synchronous model once the workers channel is exhausted.</p>

<p>This performs much better than before. Benchmarking puts it at about the same
speed as the built-in sort.Ints, but still slower than our basic Qsort
implementation for a shuffled slice of 10 million elements created by
math/rand.Perm. Playing around with MAXGOROUTINES I seemed to get slight
variations when using numbers anywhere from 2 to 10000 (make sure you have the
GOMAXPROCS environment variable set to the number of cores you want to use
so that goroutines are executed in parallel). Above 10000 and performance starts
to degrade.</p>

<p>This use of Go&rsquo;s concurrency features purely for the purpose of parallelizing
code goes against Rob Pike&rsquo;s &ldquo;Concurrency is not Parallelism&rdquo; talk, so I&rsquo;m not
surprised that I don&rsquo;t see a significant speedup when trying to parallelize this
concurrent code against the sequential version. I am surprised that I don&rsquo;t get
similar speeds to the sequential version when setting MAXGOROUTINES to 1 as the
code is essentially executing sequentially in this case. Perhaps the few extra
statements and branches are enough to slow things down considerably. In any case
it was a good experiment in writing concurrent Go that also forced me to dive
into profiling with pprof and using Go&rsquo;s support for writing benchmarks in test
code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing the Azundo Blog]]></title>
    <link href="http://azundo.github.io/blog/introducing-the-azundo-blog/"/>
    <updated>2013-06-12T12:05:00-04:00</updated>
    <id>http://azundo.github.io/blog/introducing-the-azundo-blog</id>
    <content type="html"><![CDATA[<p>A new day and a new blog. As I transition from my past role as a Market
Development Specialist with Engineers Without Borders Canada toward a more
technically focused time, I thought it might be useful to start a more
technical blog. At one point I had intended to write about technical things
over at <a href="http://theborrowedbicycle.ca">http://theborrowedbicycle.ca</a> but I&rsquo;ll keep that for thoughts on
personal and human development instead of design and engineering.</p>

<p>The intention of this blog is to keep track of what I&rsquo;m learning and thinking
about as I get my coding chops back to re-enter the technical world.  Right now
my goal is to simply use this blog to record my progress and learnings for
myself and to continue to work on my writing skills and technical
communication.  I&rsquo;ve got a few projects that I hope to blog about as I work on
them over the summer, aiming to land a job as a software engineer starting in
September.</p>
]]></content>
  </entry>
  
</feed>
