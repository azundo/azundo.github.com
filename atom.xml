<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Azundo Design]]></title>
  <link href="http://azundo.github.io/atom.xml" rel="self"/>
  <link href="http://azundo.github.io/"/>
  <updated>2013-08-20T15:43:26-07:00</updated>
  <id>http://azundo.github.io/</id>
  <author>
    <name><![CDATA[Ben Best]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing dj-timelinejs]]></title>
    <link href="http://azundo.github.io/blog/introducing-dj-timelinejs/"/>
    <updated>2013-08-20T15:37:00-07:00</updated>
    <id>http://azundo.github.io/blog/introducing-dj-timelinejs</id>
    <content type="html"><![CDATA[<p>I’ve been working on packaging up some components from my work with Engineers
Without Borders. One really great Knowledge Management Tool we use is buildling
timelines with <a href="http://timeline.verite.co/">TimelineJS</a>. Our custom KM site is
written in Django and wanted an easy way to integrate timelines with the site,
so I created <a href="https://github.com/azundo/dj-timelinejs/">dj-timelinejs</a>.</p>

<p>The package is pip-installable with <code>pip install dj-timelinejs</code> and provides
admin-interface access to created timelines and a bunch of class-based views
for viewing and importing existing timelines that you may have hosted in Google
Spreadsheets. Documentation is in the
<a href="https://github.com/azundo/dj-timelinejs/blob/master/README.md">README</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Optimal Fox AI Using State Machines]]></title>
    <link href="http://azundo.github.io/blog/an-optimal-fox-using-state-machines/"/>
    <updated>2013-07-05T16:34:00-07:00</updated>
    <id>http://azundo.github.io/blog/an-optimal-fox-using-state-machines</id>
    <content type="html"><![CDATA[<style>
    .fox-hole.selected {
        fill: white;
        stroke: black;
    }
    #fox {
        width: 600px;
        overflow: auto;
        min-height: 300px;
    }
</style>

<p>I’ve really enjoyed thinking about the puzzles at
<a href="http://gurmeet.net/puzzles/">http://gurmeet.net/puzzles/</a>, especially
looking for ways to solve them or get hints as to how to solve them using
visualization without knowing the answers.
<a href="http://azundo.github.io/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle/">Last Time</a>
I explored puzzle 11, Treasure Island, and this time I’ll look at puzzle 5, Fox
in a Hole.</p>

<h2 id="the-puzzle">The Puzzle</h2>
<p>Here is the wording from <a href="http://gurmeet.net/puzzles/">http://gurmeet.net/puzzles/</a>:</p>

<pre><code>Consider five holes in a line. One of them is occupied by a fox. Each night,
the fox moves to a neighboring hole, either to the left or to the right. Each
morning, you get to inspect a hole of your choice. What strategy would ensure
that the fox is eventually caught?
</code></pre>

<h2 id="the-challenge">The Challenge</h2>
<p>The question I asked was, can we, without knowledge of a working strategy,
create a fox that plays optimally against us so we can be sure we’ve come up
with a strategy that will work? We could simulate a fox that chooses to move
left or right randomly, but we would never be sure that our strategy is fool
proof. Can we make sure our fox plays hard to get if we don’t even know how
to catch it? Turns out we can. Try out the demo of my solution and see if you
can both figure out how to catch the fox and understand why a strategy works.
Implementation details are below the demo. Code is at 
<a href="https://gist.github.com/azundo/5941503">https://gist.github.com/azundo/5941503</a>.</p>

<h3 id="instructions">Instructions</h3>

<pre><code>Click on a hole to select it for inspection. You win if the fox has nowhere
left to hide. If you give up, click the button and one possible path the fox
could have taken to avoid your inspections will be shown.
</code></pre>

<div id="fox"></div>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script type="text/javascript">
(function(){
  var
    foxHoleR = 45,
    xOffset = foxHoleR*2 + 15,
    yOffset = foxHoleR/4 + 40,
    container = d3.select('#fox'),
    svg,
    currentDay,
    button,
    selector,

  /*
   * State machine functions
   *
   * In this example, a state is the set of possible holes that the fox could
   * be in on a given day after accounting for the farmer's strategy up to that
   * point.
   *
   * For example on the first day, after the farmer inspects a hole, it is
   * possible that the fox is in any of the other holes, so the state for the
   * first day would have four entries.
   *
   * We could represent our state space as a 5-bit bit vector, where a bit is
   * on if the fox could be in that hole, and off if the fox couldn't be in
   * that hole. I think this representation (an array of possible values) is a
   * bit easier to follow and less accessible bit manipulation.
   */

  ADJACENCY_LIST = [
    // hole 0 is next to hole 1
    [1],
    // hole 1 is next to hole 0 and hole 2
    [0, 2],
    // etc.
    [1, 3],
    [2, 4],
    [3]
    ],
  state,
  stateHistory;


  function nextState(pastState, guess) {
    /*
     * Calculates our next state based on the past state and the next hole to be inspected.
     */
    var next = [], i, j, possiblePastHole, possibleNextHoles, possibleNextHole;
    for (i = 0; i < pastState.length; i++) {
      // any value in our pastState represents a hole that the fox was possibly in yesterday
      possiblePastHole = pastState[i];

      // look up holes next to the possiblePastHole in our ADJACENCY_LIST
      possibleNextHoles = ADJACENCY_LIST[possiblePastHole];
      for (j = 0; j < possibleNextHoles.length; j++) {
        // any holes that are ajacent to a possible hole from the pastState
        // are valid holes for the fox in the next state, provided that hole wasn't inspected.
        // Note that the fox cannot stay in the same hole, it has to move to an adjacent hole.
        possibleNextHole = possibleNextHoles[j]
        // don't add holes that are already in the next state array since our
        // state is the set of possible holes
        if (possibleNextHole !== guess && next.indexOf(possibleNextHole) === -1) {
          next.push(possibleNextHole);
        }
      }
    }
    return next;
  }

  function getPossibleSequence() {
    // only depends on our stateHistory
    var i, finalState, stateToDetermine, possibleHoles, possibleHole, seq = [];
    if (stateHistory.length === 0) {
      return seq;
    }
    finalState = stateHistory.pop();
    // pick whatever hole happens to be listed first in the final state to end our sequence.
    seq.unshift(finalState[0]);
    // work backwards through the state history, picking a valid state from each 
    // entry and unshifting it onto the front of the sequence
    while (stateHistory.length > 0) {
      stateToDetermine = stateHistory.pop();
      // find a hole beside the hole at the front of our sequence
      // since our 'graph' is not directed, we can safely use
      // the same adjacency values to move backwards through
      // the state list
      possibleHoles = ADJACENCY_LIST[seq[0]];
      for (i = 0; i < possibleHoles.length; i++) {
        possibleHole = possibleHoles[i];
        // if the possible hole is in our stateToDetermine, use it.
        if (stateToDetermine.indexOf(possibleHole) !== -1){
          seq.unshift(possibleHole);
          break;
        }
      }
    }
    return seq;
  }

  /*
   * End of State Machine Functions
   */

  function selectHole(selection) {
      // update state information
      state = nextState(state, selection);
      stateHistory.push(state.slice());
      // if there are no possible holes for the fox to be in, we caught him!
      if (state.length === 0) {
        foxCaught(selection);
      } else {
        advanceOneDay(selection);
      }
  }

  function foxCaught(selection) {
    alert("You got him!");
    // remove the selector
    selector.remove();

    // our last state was where we caught the fox, so remove the empty state
    // and push on a state containing the selection that caught the fox.
    stateHistory.pop();
    stateHistory.push([selection]);

    // draw the current selection
    drawHoles(currentDay, currentDay, selection);

    // draw all foxes in
    drawFoxes();

    // reset the button
    button
      .text('Try Again')
      .on('click', init);
  }

  function advanceOneDay(selection) {

    // increase size of container div and/or svg canvas
    updateCanvasSizes();

    // move the selector down
    moveSelector();

    // draw in row with our selection
    drawHoles(currentDay, currentDay, selection);

    // fill in 'missed' label
    labelMissed(currentDay, selection);

    // increase our day counter
    currentDay += 1;

  }

  init();

  function init() {
    state = [0, 1, 2, 3, 4];
    stateHistory = [];
    container.html('');
    svg = container.append('svg')
      .attr('width', 600)
      .attr('height', 2*yOffset);
    currentDay = 0;
    button = container.append('button')
      .text('I give up. Show me the fox!')
      .on('click', giveUp);
    selector = drawHoles('selector', 0);
    selector.selectAll('.fox-hole')
      .on('mouseover', function() {
        d3.select(this).classed('selected', true);
      })
      .on('mouseout', function() {
        d3.select(this).classed('selected', false);
      })
      .on('click', function() {
        // pull the hole number from the id. XXX pretty hacky
        var selection = parseInt(d3.select(this).attr('id').split('-').pop());
        selectHole(selection);
      });
  };


  function giveUp() {
    selector.remove();
    // case where the user didn't make any guesses, put the fox in the first hole
    if (stateHistory.length === 0) {
      drawHoles(currentDay, currentDay);
      drawFox(currentDay, 0);
    }
    else {
      drawFoxes();
    }
    button
      .text('Try Again')
      .on('click', init);
  }

  /*
   * D3 Drawing functions
   */

  function drawHoles(idSuffix, row, selected) {
    var i, hole, holes = svg.append('g')
    .attr('id', 'fox-holes-' + idSuffix)
      .attr('transform', 'translate(0,' + ((row+1) * yOffset) + ')');
    holes.append('text')
      .text('Day ' + (row + 1))
      .attr('y', yOffset / 4);
    for (i = 0; i < 5; i++) {
      hole = holes.append('ellipse')
        .attr('id', 'fox-hole-' + idSuffix + '-' + i)
        .attr('rx', foxHoleR)
        .attr('ry', foxHoleR / 4)
        .attr('cx', i * xOffset + xOffset)
        .attr('cy', foxHoleR / 4 )
        .classed('fox-hole', true);
      if (i === selected) {
        hole.classed('selected', true)
      }
    }
    return holes;
  }

  function drawFoxes() {
    var seq = getPossibleSequence(), i;
    for (i=0; i < seq.length; i++) {
      drawFox(i, seq[i]);
    }
  }

  function drawFox(row, hole) {
    d3.select("#fox-holes-" + row)
      .append('image')
      .attr('xlink:href', '../../images/fox_white.svg')
      .attr('width', foxHoleR)
      .attr('height', foxHoleR)
      .attr('x', (hole+1) * xOffset - foxHoleR / 2 )
      .attr('y', -1 * foxHoleR / 2 );
  }

  function updateCanvasSizes() {
    // increase size of svg canvas if need be
    if (svg.attr('height') < (currentDay + 3) * yOffset) {
      svg.attr('height', (currentDay + 3) * yOffset);
    }
    // add to container's height if it's too small
    // to facilitate scrolling
    var containerHeight = parseInt(container.style('min-height'));
    if (containerHeight < (currentDay + 3) * yOffset) {
      container.style('min-height', (containerHeight + yOffset*5) + 'px');
    }
  }

  function moveSelector() {
    selector
      .transition()
        .attr('transform', 'translate(0,' + (currentDay+2) * yOffset + ')');
    selector.select('text')
      .text('Day ' + (currentDay+2));
    // mouseout doesn't fire when using transform to move the selector until the mouse
    // is moved again, so manually de-select the hole
    selector.select('.fox-hole.selected')
      .classed('selected', false);
  }

  function labelMissed(row, selection) {
    d3.select("#fox-holes-" + row)
      .append('text')
      .text('Missed!')
      .attr('x', (selection+1) * xOffset - foxHoleR / 2 )
      .attr('y', foxHoleR / 3);
  }

})();
</script>

<h2 id="a-quantum-fox">A Quantum Fox</h2>
<p>Instead of modeling our fox as being in one concrete location, we’ll keep track
of all possible holes the fox could be in at any given time without getting
caught, depending on which holes we have inspected in the past. We’ll use a
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine</a> to
keep track of which holes the fox could be in. If we ever get to the state
where the fox couldn’t be in any holes without being caught, we know our
strategy is a good one. We don’t require any knowledge of the best path for
the fox to choose, or a winning strategy.</p>

<h3 id="our-state-space">Our State Space</h3>
<p>Each state in our state space will consist of all of the possible holes the fox
could be in at any one time. There are 5 holes and each hole has two states: it
is either possible for the fox to be in that hole, or not possible. This gives
us a state space of size <code>2^5 = 32</code>. We could model this as a bit vector with 5
bits, but for clarity I will use a simple array. If it is possible for the fox
to be in hole <code>i</code>, then our state array will contain <code>i</code>. We’ll number our
holes <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>.</p>

<p>For example, before we check any holes, our state would be <code>[0, 1, 2, 3, 4]</code>.
The fox could be in any hole. If we check hole <code>2</code>, then our state would move
to <code>[0, 1, 3, 4]</code>. In the case where there is no possible hole for our fox to
be in without catching him at some point, our state is an empty array <code>[]</code>.</p>

<h3 id="state-transitions">State Transitions</h3>
<p>The key implementation detail when using a state machine is our state
transitions. How do we decide which state we move to next? In our case our next
state is dependent on two things, our previous state (the set of possible holes
the fox could have been in yesterday) and our selection of which hole to check.</p>

<p>To start let’s forget about the action of checking a hole. How can we determine
what holes the fox can be in based on what holes it could have been in
yesterday? If it was possible for the fox to be in hole <code>i</code> yesterday, then it
is possible for the fox to be in any hole beside <code>i</code> today. If we iterate over
all of the holes that the fox could have been in yesterday then we’ll get the
set of holes it could be in today.</p>

<p>We’ll use a very simple adjacency list to make our lives easy. If we access
element <code>i</code> of the adjacency list we will get back an array containing all of
the holes next to <code>i</code>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">ADJACENCY_LIST</span> <span class="o">=</span> <span class="p">[</span>
</span><span class="line">    <span class="c1">// hole 0 is next to hole 1</span>
</span><span class="line">    <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">    <span class="c1">// hole 1 is next to hole 0 and hole 2</span>
</span><span class="line">    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
</span><span class="line">    <span class="c1">// etc.</span>
</span><span class="line">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span><span class="line">    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
</span><span class="line">    <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span><span class="line"><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This <a href="http://en.wikipedia.org/wiki/Adjacency_list">adjacency list</a> defines a
very simple <a href="https://en.wikipedia.org/wiki/Graph_(mathematics)">graph</a> where
each hole is a node connected by edges to each of its adjacent holes. The first
and last holes only have one adjacent hole (and thus one edge) while the others
have two.</p>

<p>Accessing element <code>0</code> of our <code>ADJACENCY_LIST</code> tells us which holes are next
to hole <code>0</code>. If we want to know the set of possible future holes, we take the
set of possible past holes and add all of the adjacent holes. Simple enough.</p>

<p>Lastly we don’t include the hole that we chose to inspect since the fox would
get caught if he ended up there. Hence, our transition function looks like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line">  <span class="kd">function</span> <span class="nx">nextState</span><span class="p">(</span><span class="nx">pastState</span><span class="p">,</span> <span class="nx">guess</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="cm">/*</span>
</span><span class="line"><span class="cm">     * Calculates our next state based on the past state and</span>
</span><span class="line"><span class="cm">     * the next hole to be inspected.</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">possiblePastHole</span><span class="p">,</span> <span class="nx">possibleNextHoles</span><span class="p">,</span> <span class="nx">possibleNextHole</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">pastState</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">// any value in our pastState represents a hole that</span>
</span><span class="line">      <span class="c1">// the fox was possibly in yesterday</span>
</span><span class="line">      <span class="nx">possiblePastHole</span> <span class="o">=</span> <span class="nx">pastState</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">      <span class="c1">// look up holes next to the possiblePastHole in our ADJACENCY_LIST</span>
</span><span class="line">      <span class="nx">possibleNextHoles</span> <span class="o">=</span> <span class="nx">ADJACENCY_LIST</span><span class="p">[</span><span class="nx">possiblePastHole</span><span class="p">];</span>
</span><span class="line">      <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">possibleNextHoles</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// any holes that are ajacent to a possible hole</span>
</span><span class="line">        <span class="c1">// from the pastState are valid holes for the fox in</span>
</span><span class="line">        <span class="c1">// the next state, provided that hole wasn&#39;t</span>
</span><span class="line">        <span class="c1">// inspected.  Note that the fox cannot stay in the</span>
</span><span class="line">        <span class="c1">// same hole, it has to move to an adjacent hole.</span>
</span><span class="line">        <span class="nx">possibleNextHole</span> <span class="o">=</span> <span class="nx">possibleNextHoles</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
</span><span class="line">        <span class="c1">// don&#39;t add holes that are already in the next</span>
</span><span class="line">        <span class="c1">// state array since our state is the set of</span>
</span><span class="line">        <span class="c1">// possible holes</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="nx">possibleNextHole</span> <span class="o">!==</span> <span class="nx">guess</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">possibleNextHole</span><span class="p">)</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">          <span class="nx">next</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">possibleNextHole</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nx">next</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If we ever end up with an empty state, the fox has nowhere to go. We must have
caught it at some point, no matter where it started and how it decided to move.</p>

<p>Every time we select a hole to inspect, we’ll update our state and push a copy
of it onto an array to keep track of what states we’ve been through in the
past. We’ll use that later.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line">  <span class="kd">function</span> <span class="nx">selectHole</span><span class="p">(</span><span class="nx">selection</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">// update state information</span>
</span><span class="line">      <span class="nx">state</span> <span class="o">=</span> <span class="nx">nextState</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">selection</span><span class="p">);</span>
</span><span class="line">      <span class="nx">stateHistory</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">slice</span><span class="p">());</span>
</span><span class="line">      <span class="c1">// if there are no possible holes for the fox to be in, we caught him!</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">foxCaught</span><span class="p">(</span><span class="nx">selection</span><span class="p">);</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">advanceOneDay</span><span class="p">(</span><span class="nx">selection</span><span class="p">);</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="reconstructing-the-foxs-moves">Reconstructing the Fox’s Moves</h3>

<p>If we save each state we reach, we can reconstruct a possible path the fox
could have taken to get to the current state. Let’s choose any arbitrary hole
from the current state, and work backwards by looking for adjacent holes in the
previous state. We are guaranteed to find a backwards path since every hole in
our current state must be possible. Here is the code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line">  <span class="kd">function</span> <span class="nx">getPossibleSequence</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// only depends on stateHistory, an array of our past states</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">finalState</span><span class="p">,</span> <span class="nx">stateToDetermine</span><span class="p">,</span> <span class="nx">possibleHoles</span><span class="p">,</span> <span class="nx">possibleHole</span><span class="p">,</span> <span class="nx">seq</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nx">stateHistory</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">return</span> <span class="nx">seq</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="nx">finalState</span> <span class="o">=</span> <span class="nx">stateHistory</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span><span class="line">    <span class="c1">// pick whatever hole happens to be listed first in the</span>
</span><span class="line">    <span class="c1">// final state to end our sequence.</span>
</span><span class="line">    <span class="nx">seq</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">finalState</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class="line">    <span class="c1">// work backwards through the state history, picking a</span>
</span><span class="line">    <span class="c1">// valid state from each entry and unshifting it onto</span>
</span><span class="line">    <span class="c1">// the front of the sequence</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="nx">stateHistory</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="nx">stateToDetermine</span> <span class="o">=</span> <span class="nx">stateHistory</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span><span class="line">      <span class="c1">// find a hole beside the hole at the front of our</span>
</span><span class="line">      <span class="c1">// sequence since our &#39;graph&#39; is not directed, we can</span>
</span><span class="line">      <span class="c1">// safely use the same adjacency values to move</span>
</span><span class="line">      <span class="c1">// backwards through the state list</span>
</span><span class="line">      <span class="nx">possibleHoles</span> <span class="o">=</span> <span class="nx">ADJACENCY_LIST</span><span class="p">[</span><span class="nx">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
</span><span class="line">      <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">possibleHoles</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">possibleHole</span> <span class="o">=</span> <span class="nx">possibleHoles</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class="line">        <span class="c1">// if the possible hole is in our stateToDetermine, use it.</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="nx">stateToDetermine</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">possibleHole</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class="line">          <span class="nx">seq</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">possibleHole</span><span class="p">);</span>
</span><span class="line">          <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nx">seq</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="demo-and-further-steps">Demo and Further Steps</h2>

<p>Throwing this together with some d3.js drawing and we get the demo from above.
The full code is in a gist at
<a href="https://gist.github.com/azundo/5941503">https://gist.github.com/azundo/5941503</a>
and viewable on <a href="http://bl.ocks.org">bl.ocks.org</a> at
<a href="http://bl.ocks.org/azundo/5941503">http://bl.ocks.org/azundo/5941503</a>.</p>

<p>You could also make solving the puzzle a bit easier if you showed all possible
holes the fox could be in as you go along, instead of only showing one possible
path at the end. Feel free to fork and implement this as a good exercise in d3
basics.</p>

<p>Now can you catch the fox?</p>

<h2 id="attributions">Attributions</h2>
<ul>
  <li><a href="http://thenounproject.com/noun/fox/#icon-No4144" target="_blank">Fox</a> designed by <a href="http://thenounproject.com/ceqq" target="_blank">Sebastian Blei</a> from The Noun Project</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using D3.js to Brute Force the Pirate Puzzle]]></title>
    <link href="http://azundo.github.io/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle/"/>
    <updated>2013-07-04T23:10:00-07:00</updated>
    <id>http://azundo.github.io/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle</id>
    <content type="html"><![CDATA[<style>
  .island {
    stroke: blue;
    stroke-width: 3;
    fill: transparent;
  }
  .tree {
    stroke: green;
    fill: green;
  }
  .grave {
    stroke: black;
    fill: black;
  }
  .flag {
    stroke: red;
    fill: red;
  }
  .treasure {
    stroke: yellow;
    fill: yellow;
  }
  .flag-path {
    stroke: black;
    fill: none;
  }
  .rise {
      stroke: red;
  }
  .run {
      stroke: blue;
  }
  .thick {
      stroke-width: 5px;
  }
</style>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<p>SPOILER ALERT. This post contains an answer to puzzle 11 Treasure Island from
<a href="http://gurmeet.net/puzzles">http://gurmeet.net/puzzles</a> which appeared on Hacker News recently. If you
want to solve it yourself first, check it out over there before reading on, or
just don’t read too far down the page.</p>

<h2 id="the-puzzle">The Puzzle</h2>
<p>Here is the wording of the puzzle:</p>

<pre><code>An old parchment has directions to a treasure chest buried in an island:

There is an unmarked grave and two tall oak trees. Walk from the grave to the
left tree, counting the number of steps. Upon reaching the left tree, turn left
by 90 degrees and walk the same number of steps. Mark the point with a flag.
Return to the grave. Now, walk towards the right tree, counting the number of
steps. Upon reaching the right tree, turn right by 90 degrees and walk the same
number of steps. Mark this point with another flag. The treasure lies at the
midpoint of the two flags.

A party of sailors reached the island. They find a pair of tall oak trees
merrily swaying in the wind. However, the unmarked grave is nowhere to be
found. They are planning to dig up the entire island. It'll take a month. Can
they do any better?
</code></pre>

<p>My high school geometry is a little fuzzy so I thought I’d do a little
empirical playing around with d3.js to get a sense of the answer before trying
to work out the math. Almost a sort of graphical brute force method. If you’re new
to d3.js this should hopefully act as a good introduction as well.</p>

<p>If you want to skip ahead, the full gist is at
<a href="https://gist.github.com/azundo/5928203">https://gist.github.com/azundo/5928203</a>
and you can use Mike Bostock’s <a href="http://bl.ocks.org">bl.ocks.org</a> to view it at
<a href="http://bl.ocks.org/azundo/5928203">http://bl.ocks.org/azundo/5928203</a>.</p>

<h2 id="brute-forcing">Brute Forcing</h2>

<h3 id="set-up">Set up</h3>

<p>We’ll start with a little bit of d3 boilerplate to set things up. There are a
few <code>g</code> elements to get our layers working properly but hopefully the comments
in the code make things clear.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="mi">960</span><span class="p">,</span>
</span><span class="line">  <span class="nx">height</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// our svg container</span>
</span><span class="line">  <span class="nx">svg</span> <span class="o">=</span> <span class="nx">d3</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;svg&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">height</span><span class="p">),</span>
</span><span class="line">  <span class="c1">// a group within our container that will hold our map features</span>
</span><span class="line">  <span class="nx">features</span> <span class="o">=</span> <span class="nx">svg</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">),</span>
</span><span class="line">  <span class="c1">// a group within our features group that will show some of the underlying geometry</span>
</span><span class="line">  <span class="nx">geometries</span> <span class="o">=</span> <span class="nx">features</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next lets set up some parameters for our treasure island.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">islandRadius</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// size of the features we are plotting on the map</span>
</span><span class="line">  <span class="nx">featureLength</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// a magic number for placing our trees. Feel free to play around with this number.</span>
</span><span class="line">  <span class="nx">treeOffset</span> <span class="o">=</span> <span class="mi">210</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// an array of tree objects with x and y properties</span>
</span><span class="line">  <span class="c1">// our trees will have the same y coordinate and x coordinates centered</span>
</span><span class="line">  <span class="c1">// around the middle of the island.</span>
</span><span class="line">  <span class="nx">trees</span> <span class="o">=</span> <span class="p">[</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">        <span class="nx">x</span><span class="o">:</span> <span class="nx">treeOffset</span><span class="p">,</span>
</span><span class="line">        <span class="nx">y</span><span class="o">:</span> <span class="nx">treeOffset</span>
</span><span class="line">    <span class="p">},</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="nx">x</span><span class="o">:</span> <span class="nx">islandRadius</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="nx">treeOffset</span><span class="p">,</span>
</span><span class="line">        <span class="nx">y</span><span class="o">:</span> <span class="nx">treeOffset</span>
</span><span class="line">    <span class="p">}],</span>
</span><span class="line">  <span class="c1">// an arbitrary initial point for our grave, we&#39;ll easily change it later through the graphic.</span>
</span><span class="line">  <span class="nx">grave</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">islandRadius</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">islandRadius</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="plotting-the-static-features">Plotting the Static Features</h3>

<p>Now we’re ready to plot the static component of our map - the island and the trees.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// create the island on top of everything. If we draw our features &quot;over top&quot;</span>
</span><span class="line"><span class="c1">// of the island then they will interfere with our event handling. Appending to</span>
</span><span class="line"><span class="c1">// the end of the svg container will put the island last in the svg hierarchy</span>
</span><span class="line"><span class="c1">// so it will always be on top. We&#39;ll give it a transparent fill so we can see</span>
</span><span class="line"><span class="c1">// through it.</span>
</span><span class="line"><span class="nx">svg</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;circle&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nx">islandRadius</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;cx&#39;</span><span class="p">,</span> <span class="nx">islandRadius</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;cy&#39;</span><span class="p">,</span> <span class="nx">islandRadius</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;island&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="c1">// create the trees - these are static so only draw them once</span>
</span><span class="line"><span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.tree&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">trees</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;images/tree.svg&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// getX and getY are simple helper functions to return properly offset x</span>
</span><span class="line">    <span class="c1">// and y coords for our square features</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If we fire this code up you’ll see the following:</p>

<div id="static"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#static').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius};

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Looking good. A couple of trees. Time to get plotting our flags and ultimately the
treasure chest location.</p>

<h3 id="adding-flags">Adding Flags</h3>

<p>The tricky part here is getting the geometry right when calculating the
location of the flags for a given location of the grave. By filling in a couple
of extra triangles it becomes clear how we can do it. Here’s a quick diagram
for the left tree:</p>

<div id="tri"></div>

<script type="text/javascript">
var svg = d3.select('#tri').append('svg')
    .attr('width', 400)
    .attr('height', 280),
    line = d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; }),
    tree = {
        x: 120,
        y: 20
    },
    grave = {
        x: 370,
        y: 120
    },
    flag = {
        x: tree.x - (grave.y - tree.y),
        y: tree.y + (grave.x - tree.x)
    },
    featureLength = 40;
// plot the tree
svg.append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', tree.x - featureLength / 2)
    .attr('y', tree.y - featureLength / 2)
    .classed('tree', true);
// plot the grave
svg.append('image')
    .attr('xlink:href', '../../images/grave.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', grave.x - featureLength / 2)
    .attr('y', grave.y - featureLength / 2)
    .classed('grave', true);
// plot the flag
svg.append('image')
    .attr('xlink:href', '../../images/flag.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', flag.x - featureLength / 2)
    .attr('y', flag.y - featureLength / 2)
    .classed('flag', true);
// draw the runs
svg.append('path')
    .attr('d', line([tree, {x: grave.x, y: tree.y}]))
    .classed('run thick', true);
svg.append('path')
    .attr('d', line([flag, {x: flag.x, y: tree.y}]))
    .classed('run thick', true);
// draw the rises
svg.append('path')
    .attr('d', line([grave, {x: grave.x, y: tree.y}]))
    .classed('rise thick', true);
svg.append('path')
    .attr('d', line([tree, {x: flag.x, y: tree.y}]))
    .classed('rise thick', true);
svg.append('path')
    .attr('d', line([grave, tree, flag]))
    .classed('flag-path thick', true);
</script>

<p>Remembering that the y-coordinate values increase downwards on our svg canvas, we can see a
couple of equivalent triangles marked by the red, blue and black lines. The
black lines are the path our pirate would mark out,
the red <script type="math/tex">rise = g_y - T_{Ly}</script> is the y-difference between the grave and the tree,
and and the blue <script type="math/tex">run = g_x - T_{Lx}</script> is the x-difference between the grave and the tree.
The coordinates of the left
flag are then given by:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Lx} & = T_{Lx} - rise \\
       & = T_{Lx} - (g_y - T_{Ly}) \\
\\
F_{Ly} & = T_{Ly} + run \\
       & = T_{Ly} + (g_x - T_{Lx})
\end{aligned}
 %]]&gt;</script>

<p>If we swap the grave and the flag in the above diagram, we can work out the
case for the right tree, turning to the right instead of the left:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Rx} & = T_{Rx} + rise \\
       & = T_{Rx} + (g_y - T_{Ry}) \\
\\
F_{Ry} & = T_{Ry} - run \\
       & = T_{Ry} - (g_x - T_{Rx})
\end{aligned}
 %]]&gt;</script>

<p>So we end up with the following function for calculating our flag placements:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// calculate the positions of the flags</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">getFlagPositions</span><span class="p">(</span><span class="nx">treePositions</span><span class="p">,</span> <span class="nx">gravePosition</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kd">var</span> <span class="nx">leftTree</span><span class="p">,</span> <span class="nx">rightTree</span><span class="p">,</span> <span class="nx">rise</span><span class="p">,</span> <span class="nx">run</span><span class="p">,</span> <span class="nx">leftFlag</span><span class="p">,</span> <span class="nx">rightFlag</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="nx">leftTree</span> <span class="o">=</span> <span class="nx">treePositions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">  <span class="nx">rightTree</span> <span class="o">=</span> <span class="nx">treePositions</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">  <span class="c1">// get left flag position</span>
</span><span class="line">  <span class="nx">rise</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
</span><span class="line">  <span class="nx">run</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
</span><span class="line">  <span class="c1">// turn 90 to the left</span>
</span><span class="line">  <span class="nx">leftFlag</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">x</span><span class="o">:</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">rise</span><span class="p">,</span>
</span><span class="line">    <span class="nx">y</span><span class="o">:</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">run</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="c1">// get right flag position</span>
</span><span class="line">  <span class="nx">rise</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
</span><span class="line">  <span class="nx">run</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
</span><span class="line">  <span class="c1">// turn 90 to the right</span>
</span><span class="line">  <span class="nx">rightFlag</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">x</span><span class="o">:</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">rise</span><span class="p">,</span>
</span><span class="line">    <span class="nx">y</span><span class="o">:</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">run</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="k">return</span> <span class="p">[</span><span class="nx">leftFlag</span><span class="p">,</span> <span class="nx">rightFlag</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We’ll need to dynamically update the positions of these flags so lets create a
draw function and call it. At the same time we’ll draw our grave in as well as
the triangles that show the walking directions for illustrative purposes. Check
out the <a href="https://gist.github.com/azundo/5928203">final version of the code</a> to
see the full <code>getPathPoints</code> function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">function</span> <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">// calculate positions</span>
</span><span class="line">  <span class="kd">var</span> <span class="nx">flags</span> <span class="o">=</span> <span class="nx">getFlagPositions</span><span class="p">(</span><span class="nx">trees</span><span class="p">,</span> <span class="nx">grave</span><span class="p">),</span>
</span><span class="line">      <span class="nx">paths</span> <span class="o">=</span> <span class="nx">getPathPoints</span><span class="p">(</span><span class="nx">trees</span><span class="p">,</span> <span class="nx">flags</span><span class="p">,</span> <span class="nx">grave</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="c1">// draw the grave</span>
</span><span class="line">  <span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.grave&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">([</span><span class="nx">grave</span><span class="p">])</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;img/grave.svg&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;grave&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="c1">// draw the flags</span>
</span><span class="line">  <span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.flag&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">flags</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;img/flag.svg&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;flag&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="c1">// draw triangles showing the flag calculations</span>
</span><span class="line">  <span class="c1">// these are in the geometries group so they appear underneath the other features</span>
</span><span class="line">  <span class="nx">geometries</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.flag-path&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">paths</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;flag-path&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="nx">line</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nx">draw</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div id="flags"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#flags').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>We’re getting somewhere. Now lets connect our mouse position to the
grave position and watch our flags dance around.</p>

<h3 id="making-the-flags-move">Making the Flags Move</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// move grave location to wherever the mouse is</span>
</span><span class="line"><span class="nx">svg</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s1">&#39;.island&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">// 8 is a magic number to make things look nice, on my screen at least.</span>
</span><span class="line">      <span class="kd">var</span> <span class="nx">mousePosition</span> <span class="o">=</span> <span class="nx">d3</span><span class="p">.</span><span class="nx">mouse</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class="line">      <span class="nx">grave</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mousePosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">      <span class="nx">grave</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">mousePosition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">      <span class="nx">draw</span><span class="p">();</span>
</span><span class="line">  <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div id="moving-flags"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#moving-flags').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });

// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-1')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-1)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Can you guess the answer to the riddle yet? Let’s add a calculation of the
flags’ midpoint and plot our treasure chest on the map.</p>

<h3 id="the-chest">The Chest</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// modified draw function</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line">  <span class="kd">var</span> <span class="nx">treasure</span> <span class="o">=</span> <span class="nx">getTreasurePosition</span><span class="p">(</span><span class="nx">flags</span><span class="p">);</span>
</span><span class="line">  <span class="c1">// draw the treasure location</span>
</span><span class="line">  <span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.treasure&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">([</span><span class="nx">treasure</span><span class="p">])</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;img/treasure_chest.svg&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;treasure&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">);</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">function</span> <span class="nx">getTreasurePosition</span><span class="p">(</span><span class="nx">flagPositions</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">// averages the x and y values of the two flag positions</span>
</span><span class="line">  <span class="k">return</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">x</span><span class="o">:</span> <span class="p">(</span><span class="nx">flagPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">flagPositions</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
</span><span class="line">    <span class="nx">y</span><span class="o">:</span> <span class="p">(</span><span class="nx">flagPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">flagPositions</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div id="treasure"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#treasure').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });
// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-2')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-2)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave),
      treasure = getTreasurePosition(flags);

  // draw the treasure location
  features.selectAll('.treasure')
    .data([treasure])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/treasure_chest.svg')
      .classed('treasure', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Success! We’ve now got a clear answer - there’s only a single location where
the chest could be. If you play around with the grave position it becomes
obvious that the chest’s x-coordinate is the midpoint of the two trees’
x-coordinates and the y coordinate is simply that same midpoint distance added
to the y-coordinate of the trees. Here we’re assuming the trees are at the same
y-coordinate and remember that y increases in the downward direction on our
screen. (The y-coordinate assumption is ok because we could always redraw our
coordinate system so that the two trees are level in the y direction.)</p>

<h2 id="the-math">The Math</h2>

<p>Now that we’ve played around with getting the example to work and
seen that it is a single point solution (not a line or other area function) we
can take a more informed approach to the math.</p>

<h3 id="the-x-coordinate">The X-coordinate</h3>

<p>We’ll use the trick that our x and y coordinates are independent. Lets work in
the x-direction first. We know our final x-coordinate is the average of our two
flags’ x-coordinates. Lets start with the left tree’s flag. Here we use
<script type="math/tex">T_{Lx}</script> as the left tree’s x-coordinate, <script type="math/tex">F_{Lx}</script> as the left flag’s
x-coordinate, <script type="math/tex">g_{x}</script> as the grave’s x-coordinate and <script type="math/tex">X_{x}</script> (since X
marks the spot) as the chest’s x-coordinate. Going back to our earlier
formulas:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Lx} & = T_{Lx} - (g_{y} - T_{Ly}) \\
F_{Rx} & = T_{Rx} + (g_{y} - T_{Ry})
\end{aligned}
 %]]&gt;</script>

<p>Averaging these two we can see that our $g_{y}$ term cancels out.</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
X_{x} & = \frac{F_{Lx} + F_{Rx}}{2} \\
& = \frac{T_{Lx} - (g_{y} - T_{Ly}) + T_{Rx} + (g_{y} - T_{Ry})}{2} \\
& = \frac{T_{Lx} + T_{Ly} + T_{Rx} - T_{Ry}}{2}
\end{aligned}
 %]]&gt;</script>

<p>In our case where <script type="math/tex">T_{Ly} == T_{Ry}</script> we get <script type="math/tex">X_{x}</script> as the average of
<script type="math/tex">T_{Lx}</script> and <script type="math/tex">T_{Rx}</script>, not dependent on the graveyard location, as we saw
in our brute force method.</p>

<h3 id="the-y-coordinate">The Y-coordinate</h3>

<p>Now we can do the same for the y-coordinate.</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{aligned}
F_{Ly} & = T_{Ly} + (g_{x} - T_{Lx}) \\
F_{Ry} & = T_{Ry} - (g_{x} - T_{Rx}) \\
\\
X_{y} & = \frac{F_{Ly} + F_{Ry}}{2} \\
      & = \frac{T_{Ly} + g_{x} - T_{Lx} + T_{Ry} - g_{x} + T_{Rx}}{2} \\
      & = \frac{T_{Ly} + T_{Ry} + T_{Rx} - T_{Lx}}{2}
\end{aligned}
 %]]&gt;</script>

<p>In the case where
<script type="math/tex">T_{Ly} == T_{Ry} == T_{y}</script> then 
<script type="math/tex">X_{y} = T_{y} + \frac{T_{Rx} - T_{Lx}}{2}</script>, the result we saw earlier in
the brute force method.</p>

<h2 id="one-more-thing">One More Thing</h2>

<p>We actually don’t have it quite right yet, there is an omission. In the cases
where the grave lies above the trees (from our vantage point looking down at
the map of the island) the left and right trees are actually reversed. Here’s
the final implementation accounting for this possibility. Check out the 
gist at
<a href="https://gist.github.com/azundo/5928203">https://gist.github.com/azundo/5928203</a>
for the full final version.</p>

<div id="full"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#full').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });
// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-3')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-3)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave),
      treasure = getTreasurePosition(flags);

  // draw the treasure location
  features.selectAll('.treasure')
    .data([treasure])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/treasure_chest.svg')
      .classed('treasure', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag,
      flagPositions, leftTreeIdx, rightTreeIdx;

  // XXX assume grave position is either above or below both, 
  // i.e. y positions are equal for both trees
  // this code determines which tree is "left" and which is "right" based
  // on the location of the grave
  if (
      (treePositions[0].x < treePositions[1].x && treePositions[0].y < grave.y) ||
      (treePositions[0].x > treePositions[1].x && treePositions[0].y > grave.y)
     ) {
    leftTreeIdx = 0;
    rightTreeIdx = 1;
  } else {
    leftTreeIdx = 1;
    rightTreeIdx = 0;
  }

  leftTree = treePositions[leftTreeIdx];
  rightTree = treePositions[rightTreeIdx];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  flagPositions = [];
  // use these indexes to keep the order of our flags consistent with the order
  // of our trees in the trees array
  flagPositions[leftTreeIdx] = leftFlag;
  flagPositions[rightTreeIdx] = rightFlag;
  return flagPositions;
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<h2 id="conclusion">Conclusion</h2>

<p>So that’s it. A quick prototype in D3 to brute force our solution so we’ve got
some intution on how to go about solving the geometry. Great practice in
getting simple things done using d3.js and jogging the old geometry proofs
portion of the brain.</p>

<h2 id="attributions">Attributions</h2>

<p>Thanks to the folks over at <a href="http://thenounproject.com">The Noun Project</a> for
their svg icon sets. Here are the attributions:</p>

<ul>
  <li><a href="http://thenounproject.com/noun/tree/#icon-No17078">Tree</a> James Keunning from The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/grave/#icon-No11453">Grave</a> Alex Fuller from The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/flag/#icon-No485">Flag</a> The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/chest/#icon-No7173">Chest</a> Victor N. Escorsin da silva from The Noun Project</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concurrent Qsort in Go - Part II]]></title>
    <link href="http://azundo.github.io/blog/concurrent-qsort-in-go-part-ii/"/>
    <updated>2013-06-25T13:46:00-07:00</updated>
    <id>http://azundo.github.io/blog/concurrent-qsort-in-go-part-ii</id>
    <content type="html"><![CDATA[<p>After my <a href="https://azundo.github.io/blog/concurrent-quicksort-in-go">past attempt</a> at writing a
concurrent Qsort algorithm I had a few more thoughts about how to change the
architecture.</p>

<p>Instead of creating new channels to pass to every recursively-called goroutine
and then blocking on them until they return, I wanted to create only a single
channel for communication and find a way to return from goroutines immediately.
The solution I came up with is to send back the integer value of the number of
elements in their sorted position when a goroutine returns. In the naive case,
this is when the list is 0 or 1 elements long, leaving this fairly simple code.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Cqsort2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// this channel will collect the number of sorted elements</span>
</span><span class="line">	<span class="nx">returnChannel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">returnChannel</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// sum up the number of sorted elements until they equal</span>
</span><span class="line">    <span class="c1">// the length of our original slice</span>
</span><span class="line">	<span class="k">for</span> <span class="nx">sortedElements</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">sortedElements</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="p">{</span>
</span><span class="line">		<span class="nx">sortedElements</span> <span class="o">+=</span> <span class="o">&lt;-</span><span class="nx">returnChannel</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">	    <span class="c1">// report the number of sorted elements to the</span>
</span><span class="line">        <span class="c1">// communication channel</span>
</span><span class="line">		<span class="nx">done</span> <span class="o">&lt;-</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">
</span><span class="line">	<span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// this goroutine should now return immediately and</span>
</span><span class="line">    <span class="c1">// doesn&#39;t have to block on the child calls</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This still creates too many goroutines and uses too much memory. So taking a
page from most quicksort implementations, lets use a selection sort for the last
few elements. Empirically I found a value of about 75 to be ok. Our overall
architecture doesn’t have to change, just add the selection sort call in the
termination condition of our qsort2 function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">75</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// run a selection sort when s is small</span>
</span><span class="line">        <span class="nx">selectionSort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">	    <span class="c1">// report the number of sorted elements to the</span>
</span><span class="line">        <span class="c1">// communication channel</span>
</span><span class="line">		<span class="nx">done</span> <span class="o">&lt;-</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">
</span><span class="line">	<span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// this goroutine should now return immediately and</span>
</span><span class="line">    <span class="c1">// doesn&#39;t have to block on the child calls</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Finally when using GOMAXPROCS=2 I got a better running time for the concurrent
version over the non-concurrent Qsort from my last post. This isn’t quite a fair
comparison though because I wasn’t using the selectionSort trick in Qsort.
Adding it in to Qsort and our previous Cqsort brings all three implementations
to about 7s to sort 1 milllion elements. So still no improvements over a
sequential implementation despite using both of my cores at 100% in the
concurrent cases. Memory and communication overhead still provide too much of a
slow down.  I’m hoping to get my hands on a computer with 4 cores to see if the
concurrent version will see a speedup when doubling the core count again, or if
communication overhead is still too high.</p>

<p>Again, all of the code and some benchmarking is in a github repository at
<a href="https://github.com/azundo/cqsort.git">https://github.com/azundo/cqsort.git</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concurrent quicksort in Go]]></title>
    <link href="http://azundo.github.io/blog/concurrent-quicksort-in-go/"/>
    <updated>2013-06-23T22:05:00-07:00</updated>
    <id>http://azundo.github.io/blog/concurrent-quicksort-in-go</id>
    <content type="html"><![CDATA[<p>I’ve been playing around with Go to get some experience in a systems programming
language before applying for applying jobs. I’ve never done concurrent/parallel
programming so I thought I’d try to learn about some of Go’s concurrency tools
by implementing quicksort concurrently.</p>

<p>I started by writing a simple in-place quicksort implementation. The majority of
the algorithm happens in a <code>partition</code> function which picks a random pivot and
then does in-place swapping to partition around the pivot. With this in place
the sequential algorithm falls into place easily.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">    <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class="line">    <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
</span><span class="line">    <span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Since the divide and conquer nature of quicksort means the recursive calls to
Qsort don’t touch the same memory, this should be a decent candidate for
concurrency.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">d</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</span><span class="line">    <span class="o">&lt;-</span><span class="nx">d</span>
</span><span class="line">    <span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// termination condition</span>
</span><span class="line">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">        <span class="k">return</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// where the work happens</span>
</span><span class="line">    <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// communication channel</span>
</span><span class="line">    <span class="nx">childChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">childChan</span><span class="p">)</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">childChan</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// block until both concurrent children finish</span>
</span><span class="line">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class="line">        <span class="o">&lt;-</span><span class="nx">childChan</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// tell our caller we are done</span>
</span><span class="line">    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This works but is incredibly slow. Goroutines are cheap but not free. For large
s this program spends most of its time in garbage collection as too many
goroutines are created.</p>

<p>We need to limit the number of goroutines.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="nx">workers</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">MAXGOROUTINES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">MAXGOROUTINES</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class="line">		<span class="nx">workers</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workers</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="c1">// report to caller that we&#39;re finished</span>
</span><span class="line">	<span class="k">if</span> <span class="nx">done</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="p">}()</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="c1">// since we may use the doneChannel synchronously</span>
</span><span class="line">	<span class="c1">// we need to buffer it so the synchronous code will</span>
</span><span class="line">	<span class="c1">// continue executing and not block waiting for a read</span>
</span><span class="line">	<span class="nx">doneChannel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="k">select</span> <span class="p">{</span>
</span><span class="line">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">workers</span><span class="p">:</span>
</span><span class="line">		<span class="c1">// if we have spare workers, use a goroutine</span>
</span><span class="line">		<span class="c1">// for parallelization</span>
</span><span class="line">		<span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">doneChannel</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line">	<span class="k">default</span><span class="p">:</span>
</span><span class="line">		<span class="c1">// if no spare workers, sort synchronously</span>
</span><span class="line">		<span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line">		<span class="c1">// calling this here as opposed to using the defer</span>
</span><span class="line">		<span class="nx">doneChannel</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="c1">// use the existing goroutine to sort above the pivot</span>
</span><span class="line">	<span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line">	<span class="c1">// if we used a goroutine we&#39;ll need to wait for</span>
</span><span class="line">	<span class="c1">// the async signal on this channel, if not there</span>
</span><span class="line">	<span class="c1">// will already be a value in the channel and it shouldn&#39;t block</span>
</span><span class="line">	<span class="o">&lt;-</span><span class="nx">doneChannel</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Setting MAXGOROUTINES limits the number of goroutines that ever get created by
switching to a synchronous model once the workers channel is exhausted.</p>

<p>This performs much better than before. Benchmarking puts it at about the same
speed as the built-in sort.Ints, but still slower than our basic Qsort
implementation for a shuffled slice of 1 million elements created by
math/rand.Perm. Playing around with MAXGOROUTINES I seemed to get slight
variations when using numbers anywhere from 2 to 10000 (make sure you have the
GOMAXPROCS environment variable set to the number of cores you want to use
so that goroutines are executed in parallel). Above 10000 and performance starts
to degrade.</p>

<p>This use of Go’s concurrency features purely for the purpose of parallelizing
code goes against Rob Pike’s “Concurrency is not Parallelism” talk, so I’m not
surprised that I don’t see a significant speedup when trying to parallelize this
concurrent code against the sequential version. I am surprised that I don’t get
similar speeds to the sequential version when setting MAXGOROUTINES to 1 as the
code is essentially executing sequentially in this case. Perhaps the few extra
statements and branches are enough to slow things down considerably. In any case
it was a good experiment in writing concurrent Go that also forced me to dive
into profiling with pprof and using Go’s support for writing benchmarks in test
code.</p>

<p>Code is all up on github at (https://github.com/azundo/cqsort).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing the Azundo Blog]]></title>
    <link href="http://azundo.github.io/blog/introducing-the-azundo-blog/"/>
    <updated>2013-06-12T12:05:00-07:00</updated>
    <id>http://azundo.github.io/blog/introducing-the-azundo-blog</id>
    <content type="html"><![CDATA[<p>A new day and a new blog. As I transition from my past role as a Market
Development Specialist with Engineers Without Borders Canada toward a more
technically focused time, I thought it might be useful to start a more
technical blog. At one point I had intended to write about technical things
over at http://theborrowedbicycle.ca but I’ll keep that for thoughts on
personal and human development instead of design and engineering.</p>

<p>The intention of this blog is to keep track of what I’m learning and thinking
about as I get my coding chops back to re-enter the technical world.  Right now
my goal is to simply use this blog to record my progress and learnings for
myself and to continue to work on my writing skills and technical
communication.  I’ve got a few projects that I hope to blog about as I work on
them over the summer, aiming to land a job as a software engineer starting in
September.</p>
]]></content>
  </entry>
  
</feed>
