
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Azundo Design</title>
  <meta name="author" content="Ben Best">

  
  <meta name="description" content=".island { stroke: blue; stroke-width: 3; fill: transparent; } .tree { stroke: green; fill: green; } .grave { stroke: black; fill: black; } .flag { &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://azundo.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Azundo Design" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Montserrat+Alternates:700' rel='stylesheet' type='text/css'>
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/SVG"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42182074-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Azundo Design</a></h1>
  
    <h2>Musings and Makings</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:azundo.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle/">Using D3.js to Brute Force the Pirate Puzzle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-04T23:10:00-04:00" pubdate data-updated="true">Jul 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><style>
  .island {
    stroke: blue;
    stroke-width: 3;
    fill: transparent;
  }
  .tree {
    stroke: green;
    fill: green;
  }
  .grave {
    stroke: black;
    fill: black;
  }
  .flag {
    stroke: red;
    fill: red;
  }
  .treasure {
    stroke: yellow;
    fill: yellow;
  }
  .flag-path {
    stroke: black;
    fill: none;
  }
  .rise {
      stroke: red;
  }
  .run {
      stroke: blue;
  }
  .thick {
      stroke-width: 5px;
  }
</style>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<p>SPOILER ALERT. This post contains an answer to puzzle 11 Treasure Island from
<a href="http://gurmeet.net/puzzles">http://gurmeet.net/puzzles</a> which appeared on Hacker News recently. If you
want to solve it yourself first, check it out over there before reading on, or
just don’t read too far down the page.</p>

<h2 id="the-puzzle">The Puzzle</h2>
<p>Here is the wording of the puzzle:</p>

<pre><code>An old parchment has directions to a treasure chest buried in an island:

There is an unmarked grave and two tall oak trees. Walk from the grave to the
left tree, counting the number of steps. Upon reaching the left tree, turn left
by 90 degrees and walk the same number of steps. Mark the point with a flag.
Return to the grave. Now, walk towards the right tree, counting the number of
steps. Upon reaching the right tree, turn right by 90 degrees and walk the same
number of steps. Mark this point with another flag. The treasure lies at the
midpoint of the two flags.

A party of sailors reached the island. They find a pair of tall oak trees
merrily swaying in the wind. However, the unmarked grave is nowhere to be
found. They are planning to dig up the entire island. It'll take a month. Can
they do any better?
</code></pre>

<p>My high school geometry is a little fuzzy so I thought I’d do a little
empirical playing around with d3.js to get a sense of the answer before trying
to work out the math. Almost a sort of graphical brute force method. If you’re new
to d3.js this should hopefully act as a good introduction as well.</p>

<p>If you want to skip ahead, the full gist is at
<a href="https://gist.github.com/azundo/5928203">https://gist.github.com/azundo/5928203</a>
and you can use Mike Bostock’s <a href="http://bl.ocks.org">bl.ocks.org</a> to view it at
<a href="http://bl.ocks.org/azundo/5928203">http://bl.ocks.org/azundo/5928203</a>.</p>

<h2 id="brute-forcing">Brute Forcing</h2>

<h3 id="set-up">Set up</h3>

<p>We’ll start with a little bit of d3 boilerplate to set things up. There are a
few <code>g</code> elements to get our layers working properly but hopefully the comments
in the code make things clear.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="mi">960</span><span class="p">,</span>
</span><span class="line">  <span class="nx">height</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// our svg container</span>
</span><span class="line">  <span class="nx">svg</span> <span class="o">=</span> <span class="nx">d3</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;svg&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">height</span><span class="p">),</span>
</span><span class="line">  <span class="c1">// a group within our container that will hold our map features</span>
</span><span class="line">  <span class="nx">features</span> <span class="o">=</span> <span class="nx">svg</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">),</span>
</span><span class="line">  <span class="c1">// a group within our features group that will show some of the underlying geometry</span>
</span><span class="line">  <span class="nx">geometries</span> <span class="o">=</span> <span class="nx">features</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next lets set up some parameters for our treasure island.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">islandRadius</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// size of the features we are plotting on the map</span>
</span><span class="line">  <span class="nx">featureLength</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// a magic number for placing our trees. Feel free to play around with this number.</span>
</span><span class="line">  <span class="nx">treeOffset</span> <span class="o">=</span> <span class="mi">210</span><span class="p">,</span>
</span><span class="line">  <span class="c1">// an array of tree objects with x and y properties</span>
</span><span class="line">  <span class="c1">// our trees will have the same y coordinate and x coordinates centered</span>
</span><span class="line">  <span class="c1">// around the middle of the island.</span>
</span><span class="line">  <span class="nx">trees</span> <span class="o">=</span> <span class="p">[</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">        <span class="nx">x</span><span class="o">:</span> <span class="nx">treeOffset</span><span class="p">,</span>
</span><span class="line">        <span class="nx">y</span><span class="o">:</span> <span class="nx">treeOffset</span>
</span><span class="line">    <span class="p">},</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="nx">x</span><span class="o">:</span> <span class="nx">islandRadius</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="nx">treeOffset</span><span class="p">,</span>
</span><span class="line">        <span class="nx">y</span><span class="o">:</span> <span class="nx">treeOffset</span>
</span><span class="line">    <span class="p">}],</span>
</span><span class="line">  <span class="c1">// an arbitrary initial point for our grave, we&#39;ll easily change it later through the graphic.</span>
</span><span class="line">  <span class="nx">grave</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">islandRadius</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">islandRadius</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="plotting-the-static-features">Plotting the Static Features</h3>

<p>Now we’re ready to plot the static component of our map - the island and the trees.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// create the island on top of everything. If we draw our features &quot;over top&quot;</span>
</span><span class="line"><span class="c1">// of the island then they will interfere with our event handling. Appending to</span>
</span><span class="line"><span class="c1">// the end of the svg container will put the island last in the svg hierarchy</span>
</span><span class="line"><span class="c1">// so it will always be on top. We&#39;ll give it a transparent fill so we can see</span>
</span><span class="line"><span class="c1">// through it.</span>
</span><span class="line"><span class="nx">svg</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;circle&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nx">islandRadius</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;cx&#39;</span><span class="p">,</span> <span class="nx">islandRadius</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;cy&#39;</span><span class="p">,</span> <span class="nx">islandRadius</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;island&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="c1">// create the trees - these are static so only draw them once</span>
</span><span class="line"><span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.tree&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">trees</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;images/tree.svg&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// getX and getY are simple helper functions to return properly offset x</span>
</span><span class="line">    <span class="c1">// and y coords for our square features</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;tree&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If we fire this code up you’ll see the following:</p>

<div id="static"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#static').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius};

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Looking good. A couple of trees. Time to get plotting our flags and ultimately the
treasure chest location.</p>

<h3 id="adding-flags">Adding Flags</h3>

<p>The tricky part here is getting the geometry right when calculating the
location of the flags for a given location of the grave. By filling in a couple
of extra triangles it becomes clear how we can do it. Here’s a quick diagram
for the left tree:</p>

<div id="tri"></div>

<script type="text/javascript">
var svg = d3.select('#tri').append('svg')
    .attr('width', 400)
    .attr('height', 280),
    line = d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; }),
    tree = {
        x: 120,
        y: 20
    },
    grave = {
        x: 370,
        y: 120
    },
    flag = {
        x: tree.x - (grave.y - tree.y),
        y: tree.y + (grave.x - tree.x)
    },
    featureLength = 40;
// plot the tree
svg.append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', tree.x - featureLength / 2)
    .attr('y', tree.y - featureLength / 2)
    .classed('tree', true);
// plot the grave
svg.append('image')
    .attr('xlink:href', '../../images/grave.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', grave.x - featureLength / 2)
    .attr('y', grave.y - featureLength / 2)
    .classed('grave', true);
// plot the flag
svg.append('image')
    .attr('xlink:href', '../../images/flag.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    .attr('x', flag.x - featureLength / 2)
    .attr('y', flag.y - featureLength / 2)
    .classed('flag', true);
// draw the runs
svg.append('path')
    .attr('d', line([tree, {x: grave.x, y: tree.y}]))
    .classed('run thick', true);
svg.append('path')
    .attr('d', line([flag, {x: flag.x, y: tree.y}]))
    .classed('run thick', true);
// draw the rises
svg.append('path')
    .attr('d', line([grave, {x: grave.x, y: tree.y}]))
    .classed('rise thick', true);
svg.append('path')
    .attr('d', line([tree, {x: flag.x, y: tree.y}]))
    .classed('rise thick', true);
svg.append('path')
    .attr('d', line([grave, tree, flag]))
    .classed('flag-path thick', true);
</script>

<p>Remembering that the y-coordinate values increase downwards on our svg canvas, we can see a
couple of equivalent triangles marked by the red, blue and black lines. The
black lines are the path our pirate would mark out,
the red <script type="math/tex">rise = g_y - T_{Ly}</script> is the y-difference between the grave and the tree,
and and the blue <script type="math/tex">run = g_x - T_{Lx}</script> is the x-difference between the grave and the tree.
The coordinates of the left
flag are then given by:</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{aligned}
F_{Lx} & = T_{Lx} - rise \\
       & = T_{Lx} - (g_y - T_{Ly}) \\
\\
F_{Ly} & = T_{Ly} + run \\
       & = T_{Ly} + (g_x - T_{Lx})
\end{aligned}
 %]]></script>

<p>If we swap the grave and the flag in the above diagram, we can work out the
case for the right tree, turning to the right instead of the left:</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{aligned}
F_{Rx} & = T_{Rx} + rise \\
       & = T_{Rx} + (g_y - T_{Ry}) \\
\\
F_{Ry} & = T_{Ry} - run \\
       & = T_{Ry} - (g_x - T_{Rx})
\end{aligned}
 %]]></script>

<p>So we end up with the following function for calculating our flag placements:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// calculate the positions of the flags</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">getFlagPositions</span><span class="p">(</span><span class="nx">treePositions</span><span class="p">,</span> <span class="nx">gravePosition</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kd">var</span> <span class="nx">leftTree</span><span class="p">,</span> <span class="nx">rightTree</span><span class="p">,</span> <span class="nx">rise</span><span class="p">,</span> <span class="nx">run</span><span class="p">,</span> <span class="nx">leftFlag</span><span class="p">,</span> <span class="nx">rightFlag</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="nx">leftTree</span> <span class="o">=</span> <span class="nx">treePositions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">  <span class="nx">rightTree</span> <span class="o">=</span> <span class="nx">treePositions</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">  <span class="c1">// get left flag position</span>
</span><span class="line">  <span class="nx">rise</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
</span><span class="line">  <span class="nx">run</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
</span><span class="line">  <span class="c1">// turn 90 to the left</span>
</span><span class="line">  <span class="nx">leftFlag</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">x</span><span class="o">:</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">rise</span><span class="p">,</span>
</span><span class="line">    <span class="nx">y</span><span class="o">:</span> <span class="nx">leftTree</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">run</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="c1">// get right flag position</span>
</span><span class="line">  <span class="nx">rise</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
</span><span class="line">  <span class="nx">run</span> <span class="o">=</span> <span class="nx">gravePosition</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
</span><span class="line">  <span class="c1">// turn 90 to the right</span>
</span><span class="line">  <span class="nx">rightFlag</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">x</span><span class="o">:</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">rise</span><span class="p">,</span>
</span><span class="line">    <span class="nx">y</span><span class="o">:</span> <span class="nx">rightTree</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">run</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="k">return</span> <span class="p">[</span><span class="nx">leftFlag</span><span class="p">,</span> <span class="nx">rightFlag</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We’ll need to dynamically update the positions of these flags so lets create a
draw function and call it. At the same time we’ll draw our grave in as well as
the triangles that show the walking directions for illustrative purposes. Check
out the <a href="https://gist.github.com/azundo/5928203">final version of the code</a> to
see the full <code>getPathPoints</code> function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">function</span> <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">// calculate positions</span>
</span><span class="line">  <span class="kd">var</span> <span class="nx">flags</span> <span class="o">=</span> <span class="nx">getFlagPositions</span><span class="p">(</span><span class="nx">trees</span><span class="p">,</span> <span class="nx">grave</span><span class="p">),</span>
</span><span class="line">      <span class="nx">paths</span> <span class="o">=</span> <span class="nx">getPathPoints</span><span class="p">(</span><span class="nx">trees</span><span class="p">,</span> <span class="nx">flags</span><span class="p">,</span> <span class="nx">grave</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="c1">// draw the grave</span>
</span><span class="line">  <span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.grave&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">([</span><span class="nx">grave</span><span class="p">])</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;img/grave.svg&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;grave&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="c1">// draw the flags</span>
</span><span class="line">  <span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.flag&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">flags</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;img/flag.svg&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;flag&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="c1">// draw triangles showing the flag calculations</span>
</span><span class="line">  <span class="c1">// these are in the geometries group so they appear underneath the other features</span>
</span><span class="line">  <span class="nx">geometries</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.flag-path&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">paths</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;flag-path&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="nx">line</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nx">draw</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div id="flags"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#flags').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>We’re getting somewhere. Now lets connect our mouse position to the
grave position and watch our flags dance around.</p>

<h3 id="making-the-flags-move">Making the Flags Move</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// move grave location to wherever the mouse is</span>
</span><span class="line"><span class="nx">svg</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s1">&#39;.island&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">// 8 is a magic number to make things look nice, on my screen at least.</span>
</span><span class="line">      <span class="kd">var</span> <span class="nx">mousePosition</span> <span class="o">=</span> <span class="nx">d3</span><span class="p">.</span><span class="nx">mouse</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class="line">      <span class="nx">grave</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mousePosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">      <span class="nx">grave</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">mousePosition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">      <span class="nx">draw</span><span class="p">();</span>
</span><span class="line">  <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div id="moving-flags"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#moving-flags').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });

// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-1')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-1)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Can you guess the answer to the riddle yet? Let’s add a calculation of the
flags’ midpoint and plot our treasure chest on the map.</p>

<h3 id="the-chest">The Chest</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// modified draw function</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line">  <span class="kd">var</span> <span class="nx">treasure</span> <span class="o">=</span> <span class="nx">getTreasurePosition</span><span class="p">(</span><span class="nx">flags</span><span class="p">);</span>
</span><span class="line">  <span class="c1">// draw the treasure location</span>
</span><span class="line">  <span class="nx">features</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.treasure&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">data</span><span class="p">([</span><span class="nx">treasure</span><span class="p">])</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">)</span>
</span><span class="line">    <span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;xlink:href&#39;</span><span class="p">,</span> <span class="s1">&#39;img/treasure_chest.svg&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">classed</span><span class="p">(</span><span class="s1">&#39;treasure&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">featureLength</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">getX</span><span class="p">)</span>
</span><span class="line">      <span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">getY</span><span class="p">);</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">function</span> <span class="nx">getTreasurePosition</span><span class="p">(</span><span class="nx">flagPositions</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">// averages the x and y values of the two flag positions</span>
</span><span class="line">  <span class="k">return</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">x</span><span class="o">:</span> <span class="p">(</span><span class="nx">flagPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">flagPositions</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
</span><span class="line">    <span class="nx">y</span><span class="o">:</span> <span class="p">(</span><span class="nx">flagPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">flagPositions</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div id="treasure"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#treasure').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });
// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-2')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-2)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave),
      treasure = getTreasurePosition(flags);

  // draw the treasure location
  features.selectAll('.treasure')
    .data([treasure])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/treasure_chest.svg')
      .classed('treasure', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag;

  leftTree = treePositions[0];
  rightTree = treePositions[1];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  return [leftFlag, rightFlag];
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<p>Success! We’ve now got a clear answer - there’s only a single location where
the chest could be. If you play around with the grave position it becomes
obvious that the chest’s x-coordinate is the midpoint of the two trees’
x-coordinates and the y coordinate is simply that same midpoint distance added
to the y-coordinate of the trees. Here we’re assuming the trees are at the same
y-coordinate and remember that y increases in the downward direction on our
screen. (The y-coordinate assumption is ok because we could always redraw our
coordinate system so that the two trees are level in the y direction.)</p>

<h2 id="the-math">The Math</h2>

<p>Now that we’ve played around with getting the example to work and
seen that it is a single point solution (not a line or other area function) we
can take a more informed approach to the math.</p>

<h3 id="the-x-coordinate">The X-coordinate</h3>

<p>We’ll use the trick that our x and y coordinates are independent. Lets work in
the x-direction first. We know our final x-coordinate is the average of our two
flags’ x-coordinates. Lets start with the left tree’s flag. Here we use
<script type="math/tex">T_{Lx}</script> as the left tree’s x-coordinate, <script type="math/tex">F_{Lx}</script> as the left flag’s
x-coordinate, <script type="math/tex">g_{x}</script> as the grave’s x-coordinate and <script type="math/tex">X_{x}</script> (since X
marks the spot) as the chest’s x-coordinate. Going back to our earlier
formulas:</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{aligned}
F_{Lx} & = T_{Lx} - (g_{y} - T_{Ly}) \\
F_{Rx} & = T_{Rx} + (g_{y} - T_{Ry})
\end{aligned}
 %]]></script>

<p>Averaging these two we can see that our $g_{y}$ term cancels out.</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{aligned}
X_{x} & = \frac{F_{Lx} + F_{Rx}}{2} \\
& = \frac{T_{Lx} - (g_{y} - T_{Ly}) + T_{Rx} + (g_{y} - T_{Ry})}{2} \\
& = \frac{T_{Lx} + T_{Ly} + T_{Rx} - T_{Ry}}{2}
\end{aligned}
 %]]></script>

<p>In our case where <script type="math/tex">T_{Ly} == T_{Ry}</script> we get <script type="math/tex">X_{x}</script> as the average of
<script type="math/tex">T_{Lx}</script> and <script type="math/tex">T_{Rx}</script>, not dependent on the graveyard location, as we saw
in our brute force method.</p>

<h3 id="the-y-coordinate">The Y-coordinate</h3>

<p>Now we can do the same for the y-coordinate.</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{aligned}
F_{Ly} & = T_{Ly} + (g_{x} - T_{Lx}) \\
F_{Ry} & = T_{Ry} - (g_{x} - T_{Rx}) \\
\\
X_{y} & = \frac{F_{Ly} + F_{Ry}}{2} \\
      & = \frac{T_{Ly} + g_{x} - T_{Lx} + T_{Ry} - g_{x} + T_{Rx}}{2} \\
      & = \frac{T_{Ly} + T_{Ry} + T_{Rx} - T_{Lx}}{2}
\end{aligned}
 %]]></script>

<p>In the case where
<script type="math/tex">T_{Ly} == T_{Ry} == T_{y}</script> then 
<script type="math/tex">X_{y} = T_{y} + \frac{T_{Rx} - T_{Lx}}{2}</script>, the result we saw earlier in
the brute force method.</p>

<h2 id="one-more-thing">One More Thing</h2>

<p>We actually don’t have it quite right yet, there is an omission. In the cases
where the grave lies above the trees (from our vantage point looking down at
the map of the island) the left and right trees are actually reversed. Here’s
the final implementation accounting for this possibility. Check out the 
gist at
<a href="https://gist.github.com/azundo/5928203">https://gist.github.com/azundo/5928203</a>
for the full final version.</p>

<div id="full"></div>
<script type="text/javascript">
(function(){
var width = 960,
  height = 600,
  // our svg container
  svg = d3.select('#full').append('svg')
  .attr('width', width)
  .attr('height', height),
  // a group within our container that will hold our map features
  features = svg.append('g'),
  // a group within our features group that will show some of the underlying geometry
  geometries = features.append('g');
var islandRadius = 300,
  // size of the features we are plotting on the map
  featureLength = 30,
  // a magic number for placing our trees. Feel free to play around with this number.
  treeOffset = 210,
  // an array of tree objects with x and y properties
  // our trees will have the same y coordinate and x coordinates centered
  // around the middle of the island.
  trees = [
      {
        x: treeOffset,
        y: treeOffset
    },
    {
        x: islandRadius*2 - treeOffset,
        y: treeOffset
    }],
  // an arbitrary initial point for our grave, we'll easily change it later through the graphic.
  grave = {x: islandRadius, y: islandRadius},
  // helper function for generating path values for lines
  line = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; });
// create a mask to keep features from displaying off of the island
svg.append('g')
  .append('clipPath')
    .attr('id','island-mask-3')
    .append('circle')
      .attr('r', islandRadius)
      .attr('cx', islandRadius)
      .attr('cy', islandRadius);

// apply it to the features group
features.attr('clip-path', 'url(#island-mask-3)');

// create the island on top of everything. If we draw our features "over top"
// of the island then they will interfere with our event handling. Appending to
// the end of the svg container will put the island last in the svg hierarchy
// so it will always be on top. We'll give it a transparent fill so we can see
// through it.
svg.append('circle')
  .attr('r', islandRadius)
  .attr('cx', islandRadius)
  .attr('cy', islandRadius)
  .classed('island', true);

// create the trees - these are static so only draw them once
features.selectAll('.tree')
  .data(trees)
  .enter().append('image')
    .attr('xlink:href', '../../images/tree.svg')
    .attr('width', featureLength)
    .attr('height', featureLength)
    // getX and getY are simple helper functions to return properly offset x
    // and y coords for our square features
    .attr('x', getX)
    .attr('y', getY)
    .classed('tree', true);

svg.select('.island')
  .on('mousemove', function() {
      // 8 is a magic number to make things look nice, on my screen at least.
      var mousePosition = d3.mouse(this);
      grave.x = mousePosition[0] - 8;
      grave.y = mousePosition[1] - 8;
      draw();
  });

function draw() {
  // calculate positions
  var flags = getFlagPositions(trees, grave),
      paths = getPathPoints(trees, flags, grave),
      treasure = getTreasurePosition(flags);

  // draw the treasure location
  features.selectAll('.treasure')
    .data([treasure])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/treasure_chest.svg')
      .classed('treasure', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);


  // draw the grave
  features.selectAll('.grave')
    .data([grave])
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/grave.svg')
      .classed('grave', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);

  
  // draw the flags
  features.selectAll('.flag')
    .data(flags)
      .attr('x', getX)
      .attr('y', getY)
    .enter().append('image')
      .attr('xlink:href', '../../images/flag.svg')
      .classed('flag', true)
      .attr('height', featureLength)
      .attr('width', featureLength)
      .attr('x', getX)
      .attr('y', getY);
  
  // draw triangles showing the flag calculations
  // these are in the geometries group so they appear underneath the other features
  geometries.selectAll('.flag-path')
    .data(paths)
      .attr('d', line)
    .enter().append('path')
      .classed('flag-path', true)
      .attr('d', line);
}
draw();

function getFlagPositions(treePositions, gravePosition) {
  var leftTree, rightTree, rise, run, leftFlag, rightFlag,
      flagPositions, leftTreeIdx, rightTreeIdx;

  // XXX assume grave position is either above or below both, 
  // i.e. y positions are equal for both trees
  // this code determines which tree is "left" and which is "right" based
  // on the location of the grave
  if (
      (treePositions[0].x < treePositions[1].x && treePositions[0].y < grave.y) ||
      (treePositions[0].x > treePositions[1].x && treePositions[0].y > grave.y)
     ) {
    leftTreeIdx = 0;
    rightTreeIdx = 1;
  } else {
    leftTreeIdx = 1;
    rightTreeIdx = 0;
  }

  leftTree = treePositions[leftTreeIdx];
  rightTree = treePositions[rightTreeIdx];

  // get left flag position
  rise = gravePosition.y - leftTree.y;
  run = gravePosition.x - leftTree.x;
  // turn 90 to the left
  leftFlag = {
    x: leftTree.x - rise,
    y: leftTree.y + run
  };
  // get right flag position
  rise = gravePosition.y - rightTree.y;
  run = gravePosition.x - rightTree.x;
  // turn 90 to the right
  rightFlag = {
    x: rightTree.x + rise,
    y: rightTree.y - run
  };
  flagPositions = [];
  // use these indexes to keep the order of our flags consistent with the order
  // of our trees in the trees array
  flagPositions[leftTreeIdx] = leftFlag;
  flagPositions[rightTreeIdx] = rightFlag;
  return flagPositions;
}

function getPathPoints(treePositions, flagPositions, grave) {
  // create two lines, grave -> tree -> flag -> grave for each tree
  return [
    [
      grave,
      treePositions[0],
      flagPositions[0],
      grave
    ],
    [
      grave,
      treePositions[1],
      flagPositions[1],
      grave
    ]
  ]
}

function getTreasurePosition(flagPositions) {
  // averages the x and y values of the two flag positions
  return {
    x: (flagPositions[0].x + flagPositions[1].x) / 2,
    y: (flagPositions[0].y + flagPositions[1].y) / 2
  }
}

function getX(d) {
    return d.x - featureLength/2;
}

function getY(d) {
    return d.y - featureLength/2;
}

})();
</script>

<h2 id="conclusion">Conclusion</h2>

<p>So that’s it. A quick prototype in D3 to brute force our solution so we’ve got
some intution on how to go about solving the geometry. Great practice in
getting simple things done using d3.js and jogging the old geometry proofs
portion of the brain.</p>

<h2 id="attributions">Attributions</h2>

<p>Thanks to the folks over at <a href="http://thenounproject.com">The Noun Project</a> for
their svg icon sets. Here are the attributions:</p>

<ul>
  <li><a href="http://thenounproject.com/noun/tree/#icon-No17078">Tree</a> James Keunning from The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/grave/#icon-No11453">Grave</a> Alex Fuller from The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/flag/#icon-No485">Flag</a> The Noun Project</li>
  <li><a href="http://thenounproject.com/noun/chest/#icon-No7173">Chest</a> Victor N. Escorsin da silva from The Noun Project</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/concurrent-qsort-in-go-part-ii/">Concurrent Qsort in Go - Part II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-25T13:46:00-04:00" pubdate data-updated="true">Jun 25<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>After my <a href="https://azundo.github.io/blog/concurrent-quicksort-in-go">past attempt</a> at writing a
concurrent Qsort algorithm I had a few more thoughts about how to change the
architecture.</p>

<p>Instead of creating new channels to pass to every recursively-called goroutine
and then blocking on them until they return, I wanted to create only a single
channel for communication and find a way to return from goroutines immediately.
The solution I came up with is to send back the integer value of the number of
elements in their sorted position when a goroutine returns. In the naive case,
this is when the list is 0 or 1 elements long, leaving this fairly simple code.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Cqsort2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// this channel will collect the number of sorted elements</span>
</span><span class="line">	<span class="nx">returnChannel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">returnChannel</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// sum up the number of sorted elements until they equal</span>
</span><span class="line">    <span class="c1">// the length of our original slice</span>
</span><span class="line">	<span class="k">for</span> <span class="nx">sortedElements</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">sortedElements</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="p">{</span>
</span><span class="line">		<span class="nx">sortedElements</span> <span class="o">+=</span> <span class="o">&lt;-</span><span class="nx">returnChannel</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">	    <span class="c1">// report the number of sorted elements to the</span>
</span><span class="line">        <span class="c1">// communication channel</span>
</span><span class="line">		<span class="nx">done</span> <span class="o">&lt;-</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">
</span><span class="line">	<span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// this goroutine should now return immediately and</span>
</span><span class="line">    <span class="c1">// doesn&#39;t have to block on the child calls</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This still creates too many goroutines and uses too much memory. So taking a
page from most quicksort implementations, lets use a selection sort for the last
few elements. Empirically I found a value of about 75 to be ok. Our overall
architecture doesn’t have to change, just add the selection sort call in the
termination condition of our qsort2 function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">75</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// run a selection sort when s is small</span>
</span><span class="line">        <span class="nx">selectionSort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">	    <span class="c1">// report the number of sorted elements to the</span>
</span><span class="line">        <span class="c1">// communication channel</span>
</span><span class="line">		<span class="nx">done</span> <span class="o">&lt;-</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">
</span><span class="line">	<span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">	<span class="k">go</span> <span class="nx">cqsort2</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">done</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// this goroutine should now return immediately and</span>
</span><span class="line">    <span class="c1">// doesn&#39;t have to block on the child calls</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Finally when using GOMAXPROCS=2 I got a better running time for the concurrent
version over the non-concurrent Qsort from my last post. This isn’t quite a fair
comparison though because I wasn’t using the selectionSort trick in Qsort.
Adding it in to Qsort and our previous Cqsort brings all three implementations
to about 7s to sort 1 milllion elements. So still no improvements over a
sequential implementation despite using both of my cores at 100% in the
concurrent cases. Memory and communication overhead still provide too much of a
slow down.  I’m hoping to get my hands on a computer with 4 cores to see if the
concurrent version will see a speedup when doubling the core count again, or if
communication overhead is still too high.</p>

<p>Again, all of the code and some benchmarking is in a github repository at
<a href="https://github.com/azundo/cqsort.git">https://github.com/azundo/cqsort.git</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/concurrent-quicksort-in-go/">Concurrent Quicksort in Go</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-23T22:05:00-04:00" pubdate data-updated="true">Jun 23<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I’ve been playing around with Go to get some experience in a systems programming
language before applying for applying jobs. I’ve never done concurrent/parallel
programming so I thought I’d try to learn about some of Go’s concurrency tools
by implementing quicksort concurrently.</p>

<p>I started by writing a simple in-place quicksort implementation. The majority of
the algorithm happens in a <code>partition</code> function which picks a random pivot and
then does in-place swapping to partition around the pivot. With this in place
the sequential algorithm falls into place easily.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">    <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class="line">    <span class="nx">Qsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
</span><span class="line">    <span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Since the divide and conquer nature of quicksort means the recursive calls to
Qsort don’t touch the same memory, this should be a decent candidate for
concurrency.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">d</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</span><span class="line">    <span class="o">&lt;-</span><span class="nx">d</span>
</span><span class="line">    <span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// termination condition</span>
</span><span class="line">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">        <span class="k">return</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// where the work happens</span>
</span><span class="line">    <span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// communication channel</span>
</span><span class="line">    <span class="nx">childChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">childChan</span><span class="p">)</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">childChan</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// block until both concurrent children finish</span>
</span><span class="line">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class="line">        <span class="o">&lt;-</span><span class="nx">childChan</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// tell our caller we are done</span>
</span><span class="line">    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">    <span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This works but is incredibly slow. Goroutines are cheap but not free. For large
s this program spends most of its time in garbage collection as too many
goroutines are created.</p>

<p>We need to limit the number of goroutines.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">Cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="nx">workers</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">MAXGOROUTINES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">MAXGOROUTINES</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class="line">		<span class="nx">workers</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workers</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="c1">// report to caller that we&#39;re finished</span>
</span><span class="line">	<span class="k">if</span> <span class="nx">done</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="p">}()</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class="line">		<span class="k">return</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="c1">// since we may use the doneChannel synchronously</span>
</span><span class="line">	<span class="c1">// we need to buffer it so the synchronous code will</span>
</span><span class="line">	<span class="c1">// continue executing and not block waiting for a read</span>
</span><span class="line">	<span class="nx">doneChannel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="nx">pivotIdx</span> <span class="o">:=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">	<span class="k">select</span> <span class="p">{</span>
</span><span class="line">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">workers</span><span class="p">:</span>
</span><span class="line">		<span class="c1">// if we have spare workers, use a goroutine</span>
</span><span class="line">		<span class="c1">// for parallelization</span>
</span><span class="line">		<span class="k">go</span> <span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">doneChannel</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line">	<span class="k">default</span><span class="p">:</span>
</span><span class="line">		<span class="c1">// if no spare workers, sort synchronously</span>
</span><span class="line">		<span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line">		<span class="c1">// calling this here as opposed to using the defer</span>
</span><span class="line">		<span class="nx">doneChannel</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="c1">// use the existing goroutine to sort above the pivot</span>
</span><span class="line">	<span class="nx">cqsort</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">pivotIdx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">workers</span><span class="p">)</span>
</span><span class="line">	<span class="c1">// if we used a goroutine we&#39;ll need to wait for</span>
</span><span class="line">	<span class="c1">// the async signal on this channel, if not there</span>
</span><span class="line">	<span class="c1">// will already be a value in the channel and it shouldn&#39;t block</span>
</span><span class="line">	<span class="o">&lt;-</span><span class="nx">doneChannel</span>
</span><span class="line">	<span class="k">return</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Setting MAXGOROUTINES limits the number of goroutines that ever get created by
switching to a synchronous model once the workers channel is exhausted.</p>

<p>This performs much better than before. Benchmarking puts it at about the same
speed as the built-in sort.Ints, but still slower than our basic Qsort
implementation for a shuffled slice of 1 million elements created by
math/rand.Perm. Playing around with MAXGOROUTINES I seemed to get slight
variations when using numbers anywhere from 2 to 10000 (make sure you have the
GOMAXPROCS environment variable set to the number of cores you want to use
so that goroutines are executed in parallel). Above 10000 and performance starts
to degrade.</p>

<p>This use of Go’s concurrency features purely for the purpose of parallelizing
code goes against Rob Pike’s “Concurrency is not Parallelism” talk, so I’m not
surprised that I don’t see a significant speedup when trying to parallelize this
concurrent code against the sequential version. I am surprised that I don’t get
similar speeds to the sequential version when setting MAXGOROUTINES to 1 as the
code is essentially executing sequentially in this case. Perhaps the few extra
statements and branches are enough to slow things down considerably. In any case
it was a good experiment in writing concurrent Go that also forced me to dive
into profiling with pprof and using Go’s support for writing benchmarks in test
code.</p>

<p>Code is all up on github at (https://github.com/azundo/cqsort).</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/introducing-the-azundo-blog/">Introducing the Azundo Blog</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-12T12:05:00-04:00" pubdate data-updated="true">Jun 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A new day and a new blog. As I transition from my past role as a Market
Development Specialist with Engineers Without Borders Canada toward a more
technically focused time, I thought it might be useful to start a more
technical blog. At one point I had intended to write about technical things
over at http://theborrowedbicycle.ca but I’ll keep that for thoughts on
personal and human development instead of design and engineering.</p>

<p>The intention of this blog is to keep track of what I’m learning and thinking
about as I get my coding chops back to re-enter the technical world.  Right now
my goal is to simply use this blog to record my progress and learnings for
myself and to continue to work on my writing skills and technical
communication.  I’ve got a few projects that I hope to blog about as I work on
them over the summer, aiming to land a job as a software engineer starting in
September.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/using-d3-dot-js-to-brute-force-the-pirate-puzzle/">Using D3.js to Brute Force the Pirate Puzzle</a>
      </li>
    
      <li class="post">
        <a href="/blog/concurrent-qsort-in-go-part-ii/">Concurrent Qsort in Go - Part II</a>
      </li>
    
      <li class="post">
        <a href="/blog/concurrent-quicksort-in-go/">Concurrent Quicksort in Go</a>
      </li>
    
      <li class="post">
        <a href="/blog/introducing-the-azundo-blog/">Introducing the Azundo Blog</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/azundo">@azundo</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'azundo',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Ben Best -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
